<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LYsnowQの博客小屋</title>
  
  
  <link href="https://www.lysnowq.cn/atom.xml" rel="self"/>
  
  <link href="https://www.lysnowq.cn/"/>
  <updated>2024-09-22T15:41:12.699Z</updated>
  <id>https://www.lysnowq.cn/</id>
  
  <author>
    <name>LYsnowQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++中库的使用</title>
    <link href="https://www.lysnowq.cn/posts/ef44456b.html"/>
    <id>https://www.lysnowq.cn/posts/ef44456b.html</id>
    <published>2024-09-21T12:23:07.264Z</published>
    <updated>2024-09-22T15:41:12.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库的概述和使用"><a href="#库的概述和使用" class="headerlink" title="库的概述和使用"></a>库的概述和使用</h1><p>c++的库通常包含零个部分，一个是include文件，一个是library文件，即一个包含目录和一个库目录，在包含目录中存放的是一堆头文件，这样在使用的过程中我们就可以实际使用预构建的二进制文件中的函数，而liberary文件中所包含的就是预先构建的二进制文件，在二进制文件中一般包含两种，一种是静态库，一种是动态库。但是不是所有的库都包含两种库，</p><p>静态库和动态库区别在于：</p><p>静态库使用静态链接，库会被梵高可执行文件中或者其他操作系统下可执行的文件</p><p>动态库使用动态链接，库在运行时被链接的，一些链接可以选择在程序运行时装载动态链接库，有个叫loadLibrary的函数可以在WindowsAPI中使用它作为例子。它可以载入动态库，从中拉出函数然后开始调用函数。也可以选择在程序启动时加载dll文件。</p><p>两者主要区别是，是否是连接到exe文件或者编译到exe文件中，还是在运行过程中只用放在exe文件旁边或者其他指定位置，让exe文件加载。</p><p>静态链接相对于动态链接在技术上可以更快，因为编译器或者连接器实际上可以执行连接时优化之类的</p><p>动态链接在被运行的程序载入时程序的部分将被补充完整</p><p>在vs中我们必须先设置，让它指向头文件（include文件）只有这样才知道那些函数可用，我们就可以获得函数声明，其次我们还要将linker（连接器）指向库文件（libaray）文件。无论静态库或者动态库都需要这样的操作。</p><hr><h1 id="静态库的使用例子（GLFW）："><a href="#静态库的使用例子（GLFW）：" class="headerlink" title="静态库的使用例子（GLFW）："></a>静态库的使用例子（GLFW）：</h1><p>首先我使用GLFW作为例子（下载地址：<a href="https://www.glfw.org）">https://www.glfw.org）</a></p><p>我将该文件的二进制编码放入我的项目根目录下我自己创建的dependencies作为库的存放文件，在其中再创建了GLFW文件，我复制了vc-2022和include文件放入其中，其中的vc-2022的文件最底层包含这几个文件，其中glfw3.dll时动态库，而glfw3dll.dll是与glfw3.dll配套的静态库，这样的话我们就不需要实际询问dll。如果我们没有dll对应的静态库我们也可以使用函数直接访问dll文件内的函数。</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921205548782.png" alt="image-20240921205548782"></p><p>使用方法：首先右击项目属性，<strong>确保最上方的配置和平台无误后</strong>，在c/c++的选项下有个常规中，在附加包含目录中，我们首先指定包含文件库的位置在相对位置的目录下的包含文件。</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921213050006.png" alt="image-20240921213050006"></p><p>这样在代码中我们就可以直接调用，如图所示：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921213326344.png" alt="image-20240921213326344"></p><p>其次，在引入头文件后我们可以直接调用函数，如glfwInit，此时不会报错，并且可以正常编译，但是生成时会报错，linker会显示未定义符号，这是因为我们没有链接他的库，我们无法使用它定义的函数。</p><p>添加link如下所示：</p><p>首先我们将库的目录添加进属性，链接器中的常规的附加库目录指定好库的根目录</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921213735921.png" alt="image-20240921213735921"></p><p>然后我们继续在链接器的输入中指定我们的库，注意<strong>使用分号与后方的默认配置的目录分开</strong></p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921213842767.png" alt="image-20240921213842767"></p><p>此时我们就可以正常使用库的功能了，如果上方附加库的目录未定义完整，则附加依赖项就需要额外的输入剩余完整的路径和文件名字，这将很不方便，所以在附加库目录一定要到根目录（可以根据项目的需求灵活改变）。还有种方式如下入股哦不需要头文件，如下所写即可，其中extern “C“ 意思是保持这个函数的原貌，因为可能链接到在c语言建立的库</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921214839460.png" alt="image-20240921214839460"></p><hr><h1 id="动态库的使用（接静态库的使用GLFW）："><a href="#动态库的使用（接静态库的使用GLFW）：" class="headerlink" title="动态库的使用（接静态库的使用GLFW）："></a>动态库的使用（接静态库的使用GLFW）：</h1><p>在glfw中它同时支持静态库和动态库的使用，所以头文件和大部分设置都可以不动，但是在连接其中我们需要导入动态库如下（<strong>不要直接导入dll文件否则会报错：fatal error LNK1107: 文件无效或损坏: 无法在 0x2D0 处读取</strong>）：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921221850561.png" alt="image-20240921221850561"></p><p>但是在我们编译过程中没有问题，但是如果生成或者运行时会发生如下报错如下所示：</p><p>编译时：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921220955556.png" alt="image-20240921220955556"></p><p>运行时：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921222108120.png" alt="image-20240921222108120"></p><p>此时的解决办法是将dll文件丢入我们的exe文件根目录下（一般在项目文件的Debug文件下），因为在exe文件运行时会在自己的根目录下寻找dll动态库文件，入股哦根目录下没有那么程序无法运行。</p><hr><h1 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h1><p>youtube上the cherno的cpp系列</p>]]></content>
    
    
    <summary type="html">c++的动态库和静态库的使用</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vector的使用以及优化</title>
    <link href="https://www.lysnowq.cn/posts/7270b145.html"/>
    <id>https://www.lysnowq.cn/posts/7270b145.html</id>
    <published>2024-09-21T07:30:43.367Z</published>
    <updated>2024-09-22T15:41:45.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vector的基本使用"><a href="#Vector的基本使用" class="headerlink" title="Vector的基本使用"></a>Vector的基本使用</h1><p>c++标准库为我们提供了一个动态数组的使用方法，vector在cpp中我们使用动态数组的话一般是通过vector来使用，在cpp中，我们可以一直拓展我们数组的长度，他一般情况下没有固定的大小，基本原理类似，在当前存储的数组中如果超过了数组长度，他会在内存中创建一个更长的数组并把当前数组的值复制过去，然后删除当前数组。</p><p>部分基本语法：</p><p>.push_back();    填入元素</p><p>.size();                返回元素个数</p><p>.clear();              清空所有元素</p><p>.begin();             获取第一个元素的位置</p><p>.end();                获取最后一个元素位置</p><p>.erase();             单独移除某个元素（）中需要迭代器，如.begin()+1则会删除第二个元素</p><p>Vecotr的基本使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> Vertex&amp; vertex.z)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; vertex.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vertex.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vertex.z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//push_back(),向数组中加入元素，这里加入第一个对象并给x,y,z赋值为1，2，3</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);<span class="comment">//加入第二个元素给x,y,z赋值为4，5，6</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,i&lt;vertices.<span class="built_in">size</span>();i++)<span class="comment">//size()可以直接获取数组中元素个数</span></span><br><span class="line">       std::cout &lt;&lt; vertices[i] &lt;&lt; std::endl;<span class="comment">//vector可以类似数组一样直接用下标取出其中的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Vertex&amp; v:vertices) <span class="comment">//这里使用迭代器，将vertices中的元素依次取出使用.加上&amp;是不需要复制元素更省空间</span></span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std:: endl;</span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>()+<span class="number">1</span>);<span class="comment">//删除第二个元素</span></span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">clear</span>();<span class="comment">//直接清除vertices中的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="vector的基础优化"><a href="#vector的基础优化" class="headerlink" title="vector的基础优化"></a>vector的基础优化</h1><p>vector的基本工作原理是先创建一个数组，可以让你不断地push_back加入新元素，当现有空间已经不能够容下后续继续加入的元素时，它会重新开辟一片更大的空间，将现有的数组复制到开辟的新空间，删除旧空间的内容。而在复制迁移的过程中就比较消耗时间，所以优化的切入点即为如何避免去频繁的拓展空间即复制的过程。</p><p>一些语法使用解释：</p><p>.reserve();             设置容器的元素个数</p><p>.emplace_back(); 传入参数列表构造元素</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span><br><span class="line">        :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex)</span><br><span class="line">        :<span class="built_in">x</span>(vertex.x),<span class="built_in">y</span>(vertex.y),<span class="built_in">z</span>(vertex.z)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921194312761.png" alt="image-20240921194312761"></p><p>在这里我们可以看到，进行了6次复制过程，这个过程非常的消耗性能。</p><ul><li>第一次优化:</li></ul><p>首先这里相当于每次加入新元素时就会独自开辟一个新空间，每次加入一个新的元素就会开辟一次空间，那么为了减少空间的开辟次数，我们可以手动为其开辟空间。</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改主函数代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);<span class="comment">//手动为其开辟三个元素空间</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921194806761.png" alt="image-20240921194806761"></p><p>此处，我们这里从6个减少到了3个，此处我们将vector的空间开辟工作优化掉了，那么这里的复制的原因是什么呢？首先，在我们创建加入数组时，我们创建的位置在主函数上，也就是在main的栈上创建的Vertex对象，我们创建了对象后，再将main栈的对象复制vertices里面，此时就造成了资源浪费。</p><ul><li>第二次优化：</li></ul><p>了解的复制机制后我们的目的是让对象在数组李可以在内部自己生成创建对应的元素，以省去main栈的创建复制过程</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依旧更改主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);<span class="comment">//手动为其开辟三个元素空间</span></span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240921195505425.png" alt="image-20240921195505425"></p><p>可以看到在这个过程中我们没有任何复制过程，极大的加快了代码的运行速度。</p><hr><h1 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h1><p>youtube上the cherno的cpp系列</p>]]></content>
    
    
    <summary type="html">c++的vector的基础操作和基础优化方法</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>箭头操作符</title>
    <link href="https://www.lysnowq.cn/posts/850cdb83.html"/>
    <id>https://www.lysnowq.cn/posts/850cdb83.html</id>
    <published>2024-09-20T01:24:52.762Z</published>
    <updated>2024-09-22T15:43:03.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述及常规用法"><a href="#概述及常规用法" class="headerlink" title="概述及常规用法"></a>概述及常规用法</h1><p>箭头操作符在c++中是一个提供方便的操作符，特别是在类的实例化过后与指针配合使用时作用尤为突出，在使用指针指向一个实例后，我们无法直接调用其中的成员函数，究其原因是我们的指针不是具体的实例，无法调用其中的成员函数。</p><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span><span class="comment">//如果使用的const创建的，此处也要有const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scopedstr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Scopedptr</span> (Entity* other)</span><br><span class="line">    :<span class="built_in">m_Obj</span>(other)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Scopedptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重载-&gt;</span></span><br><span class="line">    Entity* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="type">const</span><span class="comment">//如果创建时使用的为const则提供const版本</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传出m_Obj</span></span><br><span class="line">    <span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_Obj;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scopedptr entity=<span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//此处构建的Scopedptr会自动释放空间</span></span><br><span class="line">    <span class="comment">//第一种方式传递出类中的m_Obj再调用</span></span><br><span class="line">    entity.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    <span class="comment">//第二种方式用重载</span></span><br><span class="line">    entity-&gt;<span class="built_in">Print</span>();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="箭头操作符的特殊用法"><a href="#箭头操作符的特殊用法" class="headerlink" title="箭头操作符的特殊用法"></a>箭头操作符的特殊用法</h1><p>在结构体中我们在结构体中定义的变量方式顺序不同也会导致他们的存储地址在内存中的偏移量不同，如 float x,y,z 和float x,z,y在内存中偏移量是相反的（互换），即在第一个中x为0，y为4，z为8，而在第二个中z为4，y为8.此时我们需要知道每个成员偏移量时可以利用-&gt;符号来得到每个变量的相对偏移量</p><p> 例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> offest1 = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">0</span>)-&gt;x;<span class="comment">//计算x的偏移量</span></span><br><span class="line">    <span class="type">int</span> offest2 = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">0</span>)-&gt;y;<span class="comment">//计算y的偏移量</span></span><br><span class="line">    <span class="type">int</span> offest3 = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">0</span>)-&gt;z;<span class="comment">//计算z的偏移量</span></span><br><span class="line">    std::cout &lt;&lt; offest1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; offest2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; offest3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果为：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240920131542199.png" alt="image-20240920131542199"></p><p>即我们得到了x,y,z三个的偏移量</p><hr><h1 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h1><p>youtube上the cherno的cpp系列教学</p>]]></content>
    
    
    <summary type="html">c++中箭头操作符的常用和特殊用法</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++的智能指针</title>
    <link href="https://www.lysnowq.cn/posts/3f7a8e21.html"/>
    <id>https://www.lysnowq.cn/posts/3f7a8e21.html</id>
    <published>2024-09-18T13:29:29.356Z</published>
    <updated>2024-09-22T15:40:27.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul><li><p>什么是智能指针：</p><p>智能指针就是可以自己进行指针地址的创建和销毁的指针，在智能指针中，当需要开辟空间时它可以自己new一个空间来调用地址，并且在不需要的时候或者空着的时候自动delete内存空间。在使用智能指针时我们基本不需要使用new，所以智能指针的代码风格也很工整清爽。在编写代码时可以自动化管理内存。</p></li><li><p>智能指针的分类（智能指针包含在memory头文件中）：</p><ul><li>unique_ptr(作用域指针)：<strong>unique_ptr只能有一个</strong>，不能复制一个一样的指针，否则有其中一个释放时，另一个就会指向那个被释放的区域，会报错。<strong>在使用unique_ptr时我们对类的实例化过程时只能显示构造函数，不能进行隐式构造</strong>。</li><li>语法：std::unique_ptr&lt;参数模板&gt; 名字 =std::make_unique&lt;参数模板&gt;()；</li></ul><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Creat a Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destory a Entity!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Print</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is an Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;<span class="comment">//第一种创建方法</span></span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();<span class="comment">//第二种创建方法（有时可能出于异常时使用此方法，即由于构造函数出现异常时指针会为空）</span></span><br><span class="line">        </span><br><span class="line">        entity-&gt;<span class="built_in">Print</span>();<span class="comment">//像正常函数一样调用即可</span></span><br><span class="line">    &#125;<span class="comment">//当离开这个作用域时这个指针会自动销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>shared_ptr(共享指针):sharing_ptr的使用取决于使用的编译器和其中的标准库，大多数情况下，他是作为引用计数（一种用来统计你的指针有多少引用的方法）在引用计数中一旦计数为0则会自动销毁。例如用了两次sharing_ptr则引用计数为2，如果其中一个被释放了那么为1，直到最后一个也被释放才会自动销毁。</li><li>语法：std::shared_ptr&lt;参数模板&gt; 名字 =std::make_shared&lt;参数模板&gt;()；</li></ul><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Creat a Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destory a Entity!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Print</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is an Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//std::shared_ptr&lt;Entity&gt; entity(new Entity());//第一种创建方法</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();<span class="comment">//第二种创建方法,在这种方法中不写new是因为异常安全</span></span><br><span class="line">        e0 = entity;<span class="comment">//支持复制</span></span><br><span class="line">        &#125;<span class="comment">//在出这个作用域时entity就会销毁，但是e0依旧存活</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>weak_ptr:一般与shared_ptr连用，因为当shared_ptr赋值给weak_ptr时不会增加引用次数，这样可以通过weak_ptr去判断底层对象是否还存在。所有有可能weak_ptr会指向一个无效对象。</li></ul><hr><h1 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h1><p>youtube上the cherno的c++系列</p></li></ul>]]></content>
    
    
    <summary type="html">c++的智能指针的基础介绍和语法运用</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++操作符重载</title>
    <link href="https://www.lysnowq.cn/posts/11f33fa.html"/>
    <id>https://www.lysnowq.cn/posts/11f33fa.html</id>
    <published>2024-09-18T11:50:53.240Z</published>
    <updated>2024-09-22T15:40:19.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-的操作符号重载"><a href="#c-的操作符号重载" class="headerlink" title="c++的操作符号重载"></a>c++的操作符号重载</h1><ul><li>什么是操作符：</li></ul><p>操作符的本质就是代替函数执行任务的符号。有运算符号加减乘除等基础数学操作符，还有解引用，取地址符号，<strong>其中new和delete也是操作符的一种</strong>，cpp中有很多操作符，它们的本质就是调用函数或者方法所有的符号代替实现的功能的都叫做操作符，操作符自身也就是一个函数，也包括我们使用的 大括号 小括号 逗号 尖括号（左移操作和右移操作等）。</p><ul><li>重载操作符：</li></ul><p>重载操作符就是重新去定义操作符，扩充它的功能，或者重新给他一个新的含义等操作方法，是一个非常有用的操作方法，在c++中我们拥有对操作符的完全修改的权力。</p><p>重载操作符例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">        :<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x*other.x,y*other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x+other.x,y+other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> <span class="comment">//重载了加号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Add</span>(other)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Vector2 <span class="keyword">operator</span>*(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> <span class="comment">//重载了加号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Multiply</span>(other)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对==的重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> other.x==x &amp;&amp; other.y==y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在==重载基础上重载!=</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span>==other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重构操作符(因为在类外面所以要定义一个引入类的操作符)</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream,<span class="type">const</span> Vector2&amp; other)</span><br><span class="line">&#123;<span class="comment">//ostream指的是输出流</span></span><br><span class="line">    stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; other.y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">a_speed</span><span class="params">(<span class="number">10.0f</span>,<span class="number">10.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>,<span class="number">0.5f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>,<span class="number">1.1f</span>)</span></span></span><br><span class="line"><span class="function">    Vector2 final_speed1</span>=a_speed + speed * powerup;</span><br><span class="line">    Vector2 final_speed2=a_speed + speed * powerup + speed;</span><br><span class="line">    <span class="comment">//所以最终速度应该为10*1.1+0.5；</span></span><br><span class="line">    <span class="comment">//通过重构的操作符&lt;&lt;直接输出实例的值</span></span><br><span class="line">    std::cout &lt;&lt; final_speed &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(final_speed1==final_speed2)</span><br><span class="line">    <span class="keyword">if</span>(final_speed1!=final_speed2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载操作符就是赋予符合额外的功能，在py中更接近于魔术方法，但是仅限于在类中使用，但是在cpp中可以任何地方使用并且有完全的权限去更改它。</p><hr><h1 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h1><p>youtube上the cherno的cpp系列</p>]]></content>
    
    
    <summary type="html">c++符号的重载操作</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++隐式构造函数，隐式转换和explicit</title>
    <link href="https://www.lysnowq.cn/posts/6bd152cd.html"/>
    <id>https://www.lysnowq.cn/posts/6bd152cd.html</id>
    <published>2024-09-18T07:28:03.613Z</published>
    <updated>2024-09-22T15:40:45.657Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="c-中的隐式构造函数"><a href="#c-中的隐式构造函数" class="headerlink" title="c++中的隐式构造函数"></a>c++中的隐式构造函数</h1><p>在c++中允许编译器<strong>进行一次隐式转换</strong>，即将一个数据类型转化为另一个数据类型来用。像基础的char命名的用整数赋值会转化为asc码来显示，相当于一次隐形转化。而在类的构造函数中我们也可以使用这种隐式转化来构造实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> std::string name)</span><br><span class="line">        :<span class="built_in">m_age</span>(<span class="number">-1</span>),<span class="built_in">m_name</span>(name)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> age)</span><br><span class="line">        :<span class="built_in">m_age</span>(age),<span class="built_in">m_name</span>(<span class="string">&quot;Unknow&quot;</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Example&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stdL::cout &lt;&lt; e.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//以下方式都可以成功创造出一个对象，即进行了一次隐式转化创建了实例并且调用了对用的构造函数</span></span><br><span class="line">Example a=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="comment">//以下方式不可以</span></span><br><span class="line">    Example b=<span class="string">&quot;LYsnowQ&quot;</span>;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;LYsnowQ&quot;</span>);</span><br><span class="line">    <span class="comment">//此处的面板为char数组类型，如果需要正常传入则需要先将char数组类型转化为std::string而编译器只能进行一次转换所以会报错</span></span><br><span class="line">    <span class="comment">//正确方法是如下</span></span><br><span class="line">    <span class="built_in">Print</span>(std::<span class="built_in">string</span>(<span class="string">&quot;LYsnowQ&quot;</span>));</span><br><span class="line">    Example b=std::<span class="built_in">string</span>(<span class="string">&quot;LYsnowQ&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="built_in">Example</span>(<span class="string">&quot;LYsnowQ&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h1><p>在上述的隐式转换中，编译器可以帮我们进项隐式转化，但是有时候我们像禁用编译器的转化，以防止代码出现差错，呢么explicit关键字就是禁用编译器的隐式编译器的代码转化， </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Example</span><span class="params">(<span class="type">const</span> std::string name)</span></span></span><br><span class="line"><span class="function">        :m_age(<span class="number">-1</span>),m_name(name)&#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">Example</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">        :m_age(age),m_name(<span class="string">&quot;Unknow&quot;</span>)&#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Example&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stdL::cout &lt;&lt; e.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//以下方式都在使用了explicit后无法使用</span></span><br><span class="line">Example a=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="comment">//需要改成以下方式</span></span><br><span class="line">    <span class="function">Example <span class="title">a</span><span class="params">(Example(<span class="number">21</span>))</span></span>;</span><br><span class="line"><span class="built_in">Print</span>(<span class="built_in">Example</span>(<span class="string">&quot;LYsnowQ&quot;</span>));</span><br><span class="line">    <span class="comment">//或者使用以下方式：</span></span><br><span class="line">    Example a = <span class="built_in">Example</span>(<span class="number">21</span>);</span><br><span class="line">    a = <span class="built_in">Example</span>(<span class="string">&quot;LYsnowQ&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h1><p>youtube上the cherno的cpp系列教学</p>]]></content>
    
    
    <summary type="html">c++中类的隐式构造和转换规则</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>构造函数的初始化成员列表</title>
    <link href="https://www.lysnowq.cn/posts/0.html"/>
    <id>https://www.lysnowq.cn/posts/0.html</id>
    <published>2024-09-17T09:24:35.796Z</published>
    <updated>2024-09-22T15:42:34.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始化成员列表"><a href="#初始化成员列表" class="headerlink" title="初始化成员列表"></a>初始化成员列表</h1><p>在cpp中我们经常创造一些类的使用，在初始化时过多的变量会导致代码冗乱和可读性下降，在一些特定语句使用时还会带来一系列的程序安全隐患和意想不到的bug。初始化成员列表在class的成员初始化中具有相当好用，可读性强，便捷的优点。</p><p>初始化成员列表的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">析构函数名()</span><br><span class="line">    :成员<span class="number">1</span>(成员<span class="number">1</span>初始量),成员<span class="number">2</span>(成员<span class="number">2</span>初识量),.....</span><br><span class="line">&#123;</span><br><span class="line">    代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是在初始化成员列表时，初始化的成员顺序，必须按照类中成员的声明顺序进行，否则会报错。</p><p>以下为实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">        :<span class="built_in">a</span>(<span class="number">10</span>),<span class="built_in">b</span>(<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         代码块   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在一些特定情况下初始化成员列表可以避免一些额外的性能消耗的一些bug发生</p><p>例子如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Num</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is Num class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Num</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;cout &quot;</span>&lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">    std::string s_name;</span><br><span class="line">    Num m_num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    :<span class="built_in">a</span>(<span class="number">10</span>),<span class="built_in">s_name</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//s_name=&quot;A&quot;;//这里赋值时会有=额外的开销，在此处真正的赋值过程为s_name=std::string(&quot;A&quot;),相当于再次创建了一个string性能消耗会增加。   </span></span><br><span class="line">            m_num=<span class="built_in">Num</span>(<span class="number">1</span>);<span class="comment">//此处我们想构建的m_num实行第二种构造函数的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240917173920333.png" alt="image-20240917173920333"></p><p>即上述过程中两个构造函数均被实现了一次即有两次的实例对象创建。而当我们换用初始化成员列表后如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class <span class="selector-tag">A</span></span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">    std::string s_name;</span><br><span class="line">    Num m_num;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    :<span class="built_in">a</span>(<span class="number">10</span>),<span class="built_in">s_name</span>(<span class="string">&quot;A&quot;</span>),<span class="built_in">m_num</span>(<span class="built_in">Num</span>(<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时的运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240917174321789.png" alt="image-20240917174321789"></p><p>即我们只得到了使用带有传入参数的构造函数的实例的创建。</p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>YouTube上Thecherno的cpp系列</p>]]></content>
    
    
    <summary type="html">初始化成员列表的运用环境和使用方式</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>multable和const</title>
    <link href="https://www.lysnowq.cn/posts/259fcc70.html"/>
    <id>https://www.lysnowq.cn/posts/259fcc70.html</id>
    <published>2024-09-17T07:30:59.389Z</published>
    <updated>2024-09-17T09:58:21.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const深度用法"><a href="#const深度用法" class="headerlink" title="const深度用法"></a>const深度用法</h1><p>在cpp中const是声明一个常量，与其说是一个声明，不如说是一个承诺，在承诺你不回去改变他，在cpp中如同c语言一样，想要修改const声明的值是可以通过指针手段实现的。</p><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p=<span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="comment">//此时就实现了对const的值的修改</span></span><br><span class="line">    p=(<span class="type">int</span>*)&amp;a;</span><br><span class="line">    p*=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在平常中const的值不如我们所想的安全，在cpp的类中const也有它独有的使用的地方。包括于引用得一些配合</p><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">B</span><span class="params">()</span> <span class="type">const</span><span class="comment">//此处const加上后这个方法无法修改类内所有的变量，只能调用无法修改</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此处会报错</span></span><br><span class="line">        a=<span class="number">2</span></span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> <span class="title">C</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;<span class="comment">//此处为我们返回一个不可修改的地址，值得指针并且只能调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">const</span> A&amp; e)</span><span class="comment">//如果有两个B函数另一个未修饰这种情况下会调用const修饰的函数，否则就调用另一个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此时类中的B函数有const修饰才能正常调用，如果没有const修饰方法他会报错</span></span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">B</span>()&lt;,std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> A a;</span><br><span class="line">    a.<span class="built_in">B</span>();<span class="comment">//只有有const修饰过的实体对象才能调用const修饰的方法，否则会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上例子中在外部函数的调用中我们可以发现，const在数据的保护和程序的规范具有很强大的作用，那么当我们在众多数据中都被规定了无法修改，也是对数据的保护。</p><hr><h1 id="multable"><a href="#multable" class="headerlink" title="multable"></a>multable</h1><p>在multable中可以修饰数据使其能在类中的被const修饰的方法中支持修改数据。</p><p>multable有两种用法：</p><ul><li>与const联合使用</li><li>用在lambda表达式里</li><li>或者两者混合使用</li></ul><p>首先与const混合使用，在class构建过程中我们入股一直使用const修饰的函数但是其中的某些变量却是我们必修得改变的，或者为了代码的整体维护更加方便，所以我们不得不将一些变量变得可以修改，那么我们就需要multable关键字。使得数据可以在const方法中被修改。</p><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    multable <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">cosnt std::string&amp; <span class="title">B</span><span class="params">()</span> <span class="type">const</span><span class="comment">//此处const加上后这个方法无法修改类内所有的变量，只能调用无法修改</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此时可以正常修改a</span></span><br><span class="line">        a++;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在实体中const修饰的对象也可以轻松调用</span></span><br><span class="line">    cont A a;</span><br><span class="line">    a.<span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是最常见的在类中的使用。</p><p>其次是与lambda内的使用。</p><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f=[=]()<span class="keyword">mutable</span><span class="comment">//此处multable的作用是让x依旧为0进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//由于是值传递进入f则在f以外的地方引用x值时x依旧为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f=[=]()</span><br><span class="line">    &#123;<span class="comment">//不使用multable时并且想继续使用值传递就得用新变量去接收他并且改变</span></span><br><span class="line">        <span class="type">int</span> y=x;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>youtube上的thecharno的cpp系列</p>]]></content>
    
    
    <summary type="html">multible的应用方式</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>virtual和override</title>
    <link href="https://www.lysnowq.cn/posts/2379f7ax.html"/>
    <id>https://www.lysnowq.cn/posts/2379f7ax.html</id>
    <published>2024-09-16T15:35:27.926Z</published>
    <updated>2024-09-22T15:42:28.611Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h1><p>在class类中由于继承关系，很多时候容易将函数重写，从而写成一篇不符合多态的不合格函数方式。导致在引用上进行错误的引用从而输出错误的结果。那么virtual可以将函数设置为虚函数，此时如果函数被重写，程序将重新定义到一个正确的函数调用</p><ul><li>在性能消耗上，虚函数的使用将会加大内存花销，首先是需要用额外的内存来存储虚函数表以便于程序识别，其次是程序会遍历虚函数表来寻找虚函数。实际上花销不是特别大（根据项目情况具体抉择）。</li></ul><p>具体例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Example1&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example2</span> : <span class="keyword">public</span> Example1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example2</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        :<span class="built_in">m_Name</span>(name)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_Name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example1* p1= <span class="keyword">new</span> <span class="built_in">Example1</span>();</span><br><span class="line">    std::cout &lt;&lt; p1-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Example2* p2= <span class="keyword">new</span> <span class="built_in">Example2</span>(<span class="string">&quot;Example2&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p2-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Example1* p3=p2;</span><br><span class="line">    std::cout &lt;&lt; p3-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//这里用example1的指针指向了example2的实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240917113204537.png" alt="image-20240917113204537"></p><p>更加明显的使用区分如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(Example1* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example1* p1= <span class="keyword">new</span> <span class="built_in">Example1</span>();</span><br><span class="line">    Example2* p2= <span class="keyword">new</span> <span class="built_in">Example2</span>(<span class="string">&quot;Example2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PrintString</span>(p1);</span><br><span class="line">    <span class="built_in">PrintString</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20240917114238745.png" alt="image-20240917114238745"></p><p>即如上述例子所示，我们在这里使用了Example1的指针指向一个Example2的实例，由于函数名称相同，则使用了Example1的函数，其实这里的表现更像是一个完全不合格的重载函数的写法。那么要想避免函数错用的情况我们就必须使用virtual，防止函数被重写覆盖我们原本想要的内容。</p><p>修改如下：</p><blockquote><p>只需要将第一个class中的std::string GetName()函数更改为virtual std::string GetName(){return “Example1”;}即可</p></blockquote><p>即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Example1&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>纯虚函数允许我们定义一个在基类中没有实现的函数让子类强制去实现这个函数，例如上方例子中我们的Example1中的方法GetName直接返回了一个默认值，在很多时候这种方法是没有意义的，很多时候是让子类为某个特定函数提供自己的定义。<strong>这种无实现的方法通常称为“接口”，即接口就是只包含未实现方法并作为模板的一个类</strong>，由于不包含实现方法，所以我们无法实例化这个类。只有当子类函数发现使用了这个函数时,子类才能创造实例，否则也会报错。<strong>重点是纯虚函数必须被发现</strong></p><p>例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example2</span> : <span class="keyword">public</span> Example1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example2</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        :<span class="built_in">m_Name</span>(name)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_Name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Example1* p1= new Example1();//此时这行代码会报错</span></span><br><span class="line">    </span><br><span class="line">    Example2* p2= <span class="keyword">new</span> <span class="built_in">Example2</span>(<span class="string">&quot;Example2&quot;</span>);<span class="comment">//这行代码则会正常使用</span></span><br><span class="line">    <span class="comment">//如果我们将Example2中的函数方法去掉则同样不能将类实例化。</span></span><br><span class="line">    std::cout &lt;&lt; p2-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个接口示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintName</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> PrintName<span class="comment">//提供Print接口确保A类有特定方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a=<span class="keyword">new</span> A;</span><br><span class="line">    std::cout&lt;&lt; a-&gt;<span class="built_in">Print</span>() &lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><p>在上述过程中virtual的使用中基本可以排除掉复写函数的影响，但是为了增加代码的可读性和维护性，我们还可以使用override关键字，它可以明确标注出你的函数是否是复写的，并且会检查你的复写函数是否与原函数同名字，也就是你的复写函数名字是否正确，有纠错的能力，与此同时如果没有virtual关键字它同样也会报错，当然它的存在与否不影响程序的运行，即使不加也不会影响程序的正常运行。<strong>但是在虚函数使用中子类的函数重写必须加上override</strong></p><p>使用方法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数() <span class="keyword">override</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>举例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依旧使用上述的class类举例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Example1&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example2</span> : <span class="keyword">public</span> Example1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example2</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        :<span class="built_in">m_Name</span>(name)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125;<span class="comment">//override只能放在小括号后，大括号前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>YouTube上Thecherno的cpp系列</p>]]></content>
    
    
    <summary type="html">虚函数，纯虚函数（接口）</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++中static的应用</title>
    <link href="https://www.lysnowq.cn/posts/4abded85.html"/>
    <id>https://www.lysnowq.cn/posts/4abded85.html</id>
    <published>2024-09-16T13:07:45.490Z</published>
    <updated>2024-09-22T15:40:56.935Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="static概述"><a href="#static概述" class="headerlink" title="static概述"></a>static概述</h1><p>static时用于声明静态变量或者方法的关键字，在编写代码时，往往使用static</p><p>static在cpp中分为两个场景使用，一个是在类的外部使用，一个是在类的内部使用。</p><ul><li>在类的外部使用：</li></ul><blockquote><p>当我们在类的外部使用时，static往往是临时性的，当我们在两个文件中同时定义了全局变量后会出现重复定义的报错，此时使用static可以将全局变量或者函数变为局部变量或者函数，也就是作用域的改变，在编译的obj文件中，如果使用了static，那么连接器在当下的编译单元即.obj文件以外的地方寻找定义，这个方法或者函数只能在当下的文件里可见，即作用域仅限于当前所在的文件中。如果此时我们使用extern去寻找另外一个文件的用static定义的函数或者文件那么会无法找到。</p></blockquote><p>具体实例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件1.cpp</span></span><br><span class="line"><span class="type">int</span> val=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//文件2.cpp</span></span><br><span class="line"><span class="type">int</span> val=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//此时报错，相同的全局变量名字只能有一个</span></span><br></pre></td></tr></table></figure><p>使用static修改后如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件1.cpp</span></span><br><span class="line"><span class="type">int</span> val=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//文件2.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> val=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//程序会正常运行</span></span><br></pre></td></tr></table></figure><p>但是如果我们使用extern来声明，此时我们是找不到的</p><p>如下演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> val;</span><br><span class="line"><span class="comment">//文件2.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> val=<span class="number">1</span></span><br><span class="line"><span class="comment">//此时会无法找到定义的val变量</span></span><br></pre></td></tr></table></figure><ul><li>static在类以内的地方使用：</li></ul><blockquote><p>static在类中使用基本都表示一个特定的东西。意味着这个方法或者变量都只有一个实例，如果任意一个实例改变了这个量那么所有的实例中这个量也会随之改变，相当于实现了所有同种类中实例的”共享“，所以在类实例中引用静态变量没有意义，如同全局实例一样，静态方法相同，不能访问类的实例，即使是在静态方法的内部也不可以访问类的实例，而静态方法的调用需要用::来调用</p></blockquote><p>静态成员例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用struct是默认成员都为public权限</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> val1,val2;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">//当使用static后以下方法赋值会报错</span></span><br><span class="line">    t=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    t.val1=<span class="number">1</span>;</span><br><span class="line">    t.val2=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> val1,val2;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时的val1和val2属于整个T类型的全局变量，我们定义时要用如下方法</span></span><br><span class="line"><span class="comment">//此处也可以直接赋值</span></span><br><span class="line"><span class="type">int</span> T::val1;</span><br><span class="line"><span class="type">int</span> T::val2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t,t1;</span><br><span class="line">    <span class="comment">//当使用static后以下方法赋值会报错</span></span><br><span class="line">    t=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//当为静态后只有在上述10，11行定义后才能在这里赋值</span></span><br><span class="line">    t.val1=<span class="number">1</span>;</span><br><span class="line">    t.val2=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//当在t1中修改了这两个值后，在t中也会随之改变，即全局在T类中的变量只有一个</span></span><br><span class="line">    t1.val1=<span class="number">3</span>;</span><br><span class="line">    t1.val2=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//代码修正的实质如下：</span></span><br><span class="line">    T::val1=<span class="number">3</span>;</span><br><span class="line">    T::val2=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法也进行静态调用例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> val1,val2;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时的val1和val2属于整个T类型的全局变量，我们定义时要用如下方法</span></span><br><span class="line"><span class="comment">//此处也可以直接赋值</span></span><br><span class="line"><span class="type">int</span> T::val1;</span><br><span class="line"><span class="type">int</span> T::val2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T::val1=<span class="number">1</span>;</span><br><span class="line">T::val2=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//此时方法的使用也只能使用::</span></span><br><span class="line">    T::<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了非静态的变量和静态方法，那么方法就无法访问变量，因为静态方法无法访问非静态变量例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val1,val2;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//在编译器中，下方的x，y会报错，也就是静态方法没有类实例</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">t.val1=<span class="number">1</span>;</span><br><span class="line">t.val2=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//此时方法使用不变:</span></span><br><span class="line">    T::<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述中静态方法和非静态方法的区别是静态方法没有一个指向实例方法的指针，使得静态方法如同在类外部的使用，无法识别val1和val2的内容，而非静态方法则是本身存在指向实例内部的指针，可以直接调用其中的参数。</p><hr><h1 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h1><p>youtube上the cherno的cpp系列教学</p>]]></content>
    
    
    <summary type="html">cpp中对static的全面了解</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++中的构造函数和析构函数</title>
    <link href="https://www.lysnowq.cn/posts/42a67327.html"/>
    <id>https://www.lysnowq.cn/posts/42a67327.html</id>
    <published>2024-09-15T07:04:21.535Z</published>
    <updated>2024-09-17T09:10:23.513Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>在类中我们经常需要在程序开始时对程序进行初始化，而在程序结束时我们经常需要内存的清理，这将关系到我们程序的安全问题</p><p>在对象没有进行初始化时我们无法确认他的具体数据和状态，使用时也是极其危险的，而在使用完对象后没有进行及时清理也会导致留下极大的安全隐患</p></blockquote><p>而c++在程序中就内置了构造函数和析构函数来帮我们处理这个”准备工作“以及程序使用后的”烂摊子“，他们可以在程序运行时初始化对象，并且在程序运行完后进行清理。</p><p><strong>在c++中构造函数和析构函数是编译器的强制要求，如果我们没有提供独影的函数，那么编译器会自动提供的构造函数和析构函数并且是空实现</strong></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><hr><p>格式语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>构造函数没有返回值也不需要写数值返回类型</li><li>构造函数有参数，也可以与普通函数一样<strong>可以发生重载</strong></li><li>程序运行时会自动调用构造函数且只调用一次，不需要手动指定。</li></ol><ul><li>作用：主要用于创建对象时为对象的队员属性赋值，构造函数由编译器自动调用</li></ul><p>分类：</p><ol><li>有参函数和无参函数（从参数看）</li><li>普通构造和拷贝构造（从类型看）</li></ol><p>三种调用方式：</p><ol><li>括号的法。</li><li>显示法。</li><li>隐式转换法。</li></ol><p>规则：</p><p><strong>在编译器中如果写了普通有参构造函数则编译器会自动提供拷贝构造函数而不会提供无参构造函数，如果自己写了拷贝构造函数则编译器不会提供普通构造函数和拷贝构造函数。</strong> </p><p>在cpp中一般有三种情况时使用拷贝函数：</p><ol><li>使用一个已经初始化完毕的对象来初始化一个新对象</li><li>值传递方式给函数参数传值</li><li>以值返回局部对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:    </span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Car</span>(<span class="type">const</span> Car &amp;p)<span class="comment">//将传进来的对象的age属性拷贝一份为age赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        number=p.number</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//括号法</span></span><br><span class="line">    <span class="function">Car <span class="title">c1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Car <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//拷贝c1内容进入c2</span></span><br><span class="line"><span class="comment">//显示法</span></span><br><span class="line">    Car c3=c1;<span class="comment">//将c1的参数全部赋值给c3  </span></span><br><span class="line">    <span class="function">Car <span class="title">c4</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//直接赋值给c4 number 为有参构造</span></span><br><span class="line">    </span><br><span class="line">    Car c5=<span class="built_in">Car</span>(<span class="number">10</span>)<span class="comment">//右侧为匿名对象，可以将数据赋值给左侧</span></span><br><span class="line"> <span class="comment">//隐式法</span></span><br><span class="line">    Car c6=<span class="number">10</span>;<span class="comment">//这里会将值肢解赋给属性中的number</span></span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">在这里上面的c实际为c的参数，而下面的c实际为一个对象</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(Car c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">work</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在上述代码中有一个Car（10）的对象，为匿名对象，匿名对象在程序执行完后会直接被程序回收，在使用匿名函数时不要使用拷贝函数初始化对象</strong></p><p><strong>浅拷贝和深拷贝</strong>：</p><p>浅拷贝：简单的赋值操作</p><p>深拷贝：在堆区重新申请空间进行拷贝操作</p><p><strong>注意：在程序提供的拷贝函数中会对其直接进行赋值，此种操作为浅拷贝，如果含有指针的数据存在，则需要自己手动写拷贝函数并且在拷贝函数中手动开辟空间并且进行赋值</strong></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><hr><p>格式语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>析构函数没有返回值也不需要返回类型</li><li>析构函数与构造函数区别在于前面加上了~</li><li>析构函数不可以有参数所以<strong>不能发生重载</strong></li><li>在程序销毁前自动调用，无需手动操作</li></ol><p>用法：</p><p>析构函数用法很简单，不需要参数，一般是用来释放空间，销毁地址使用。</p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">c++构造函数和析构函数的用法和实例</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象（二）</title>
    <link href="https://www.lysnowq.cn/posts/b51db9d.html"/>
    <id>https://www.lysnowq.cn/posts/b51db9d.html</id>
    <published>2023-12-22T07:08:02.252Z</published>
    <updated>2024-09-17T05:42:21.981Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h1><p>类有三种权限，分别是public,protected和private.这三者区别如下：</p><p>public：类外可以访问，类内可以访问，子类可以继承父类的所有属性特征。</p><p>protected：类外不可以访问，类内可以访问，子类可以继承父类的所有特征特性。</p><p>private：类外不可以访问，类内可以访问，子类不可以继承父类所有特性。</p><p>这里的权限时逐渐封闭，在private达到最高级别。同时访问权限的确定和修改不会影响程序的性能。</p><blockquote><p>封装就是将现实世界中的属性行为转化为程序中的类的成员变量和成员方法的过程称之为封装。封装不代表所有的属性和行为都会开放给用户，即私有的成员变量和行为。封装可以很大限度的保护程序的安全，减少程序的安全隐患。</p></blockquote><ul><li>私有成员变量和方法：私有方法无法直接被类调用，私有成员无法赋值和取值</li></ul><p>私有成员和私有变量的构建方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">名称</span>：</span><br><span class="line">__成员变量名</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__方法名</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><strong>私有成员变量进行调用赋值时不会报错，但是操作无效</strong></li><li><strong>私有方法的调用会报错</strong></li><li><strong>私有成员可以由内部去使用</strong></li></ol><p>例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span>:</span><br><span class="line">    __age=<span class="number">20</span></span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__printms</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;学生信息&quot;</span>)</span><br><span class="line">        </span><br><span class="line">stu=STU(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">stu.__age=<span class="number">18</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">stu.__printms()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231222152054055.png" alt="image-20231222152054055"></p><blockquote><p> 私有成员的使用：</p><p>私有成员在类中时可以由其他公开成员方法去调用从而使用</p></blockquote><p>例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span>:</span><br><span class="line">    __age=<span class="number">20</span></span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printms</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__age &gt;=<span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;学生成年&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;学生未成年&quot;</span>)</span><br><span class="line">        </span><br><span class="line">stu=STU(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">stu.printms()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231222152652001.png" alt="image-20231222152652001"></p><p><strong>所以私有成员仅供内部成员方法使用。</strong></p><hr><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><blockquote><p>继承就是将将已有的功能调用继续使用，而被调用的部分为父类，调用的类成为子类。</p></blockquote><p>基础语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类1</span>：</span><br><span class="line">成员变量</span><br><span class="line">    </span><br><span class="line">    成员方法</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类2</span>(<span class="title class_ inherited__">类1</span>)：</span><br><span class="line">成员变量</span><br><span class="line">    </span><br><span class="line">    成员方法</span><br></pre></td></tr></table></figure><blockquote><p> <strong>在上述格式中，类1称为父类，类2称为子类，继承分类单继承和多继承即继承一个类或者继承多个类，如果子类对杜雷的某一变量需要更改则可以直接进行赋值，称之为复写</strong></p></blockquote><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">engine</span>:</span><br><span class="line">    n=<span class="number">4</span></span><br><span class="line">    <span class="built_in">id</span>=<span class="number">1105</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">engine2</span>(<span class="title class_ inherited__">engine</span>):</span><br><span class="line">    <span class="built_in">type</span>=<span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">carbox</span>:</span><br><span class="line">    length=<span class="string">&quot;长车型&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(carbox,engine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printms</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;汽车发动机缸数为<span class="subst">&#123;self.n&#125;</span>,型号为<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>,车身长短为<span class="subst">&#123;self.length&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">car=Car()</span><br><span class="line">car.printms()</span><br></pre></td></tr></table></figure><blockquote><p> 以上engine2为单继承，继承了engine的内容,在engine2中type复写了2剩下的属性则可以继续使用。而Car则是使用了多继承将engine和carbox的内容整合输出。</p></blockquote><p>输出结果为：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231222154402455.png" alt="image-20231222154402455"></p><blockquote><p>而在继承中如果出现多继承时有相同成员变量存在则会满足就近原则。即调用最靠左的父类名称中的变量</p></blockquote><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">massage1</span>:</span><br><span class="line">    ms=<span class="number">123456</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">massage2</span>:</span><br><span class="line">    ms=<span class="number">654321</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ms</span>(massage1,massage2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.ms)</span><br><span class="line">        </span><br><span class="line">MS=ms()</span><br><span class="line">MS.printf()</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231222154822273.png" alt="image-20231222154822273"></p><blockquote><p>所以输出了massage1中的内容，那么我们也可以直接选择性调用自己所需要的父类成员。</p><p>父类成员我们也可以选择直接调用</p></blockquote><p>基础格式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">super().成员变量</span><br><span class="line">super().成员方法()</span><br><span class="line"></span><br><span class="line">父类名.成员变量</span><br><span class="line">父类名.成员方法(self)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><strong>在这里用super（）在调用方法时不需要加self，但是重名时仍然会遵循就近原则</strong></li><li><strong>直接使用父类名在方法使用上需要加self</strong></li><li><strong>直接调用时会直接忽略子类的复写</strong></li></ol><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">massage1</span>:</span><br><span class="line">    ms=<span class="number">123456</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">massage2</span>:</span><br><span class="line">    ms=<span class="number">654321</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ms1</span>(massage1,massage2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(massage2.ms)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ms2</span>(<span class="title class_ inherited__">massage1</span>):</span><br><span class="line">    ms=<span class="number">123</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">super</span>().ms)</span><br><span class="line">        </span><br><span class="line">MS1=ms1()</span><br><span class="line">MS1.printf()</span><br><span class="line">MS2=ms2()</span><br><span class="line">MS2.printf()</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231222155707784.png" alt="image-20231222155707784"></p><hr><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h1><blockquote><p>多态即为多种状态，在使用不同对象时会得到不同状态。<strong>父类作为定义声明，子类作为实际对象工作。</strong></p></blockquote><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">system</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows</span>(<span class="title class_ inherited__">system</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;windows系统&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mac</span>(<span class="title class_ inherited__">system</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果系统&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printfs</span>(<span class="params">system:system</span>):</span><br><span class="line">    system.printf()</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">win=windows()</span><br><span class="line">m=mac()</span><br><span class="line"></span><br><span class="line">printfs(win)</span><br><span class="line">printfs(m)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在上述程序中子类继承父类格式，创建不同的类执行不同的代码，实现多态。</p><p>这里的父类是使用空方法，叫做抽象类（也叫接口）通常配合多态使用。</p></blockquote><ul><li><p>抽象类：含有抽象方法的类</p></li><li><p>抽象方法：方法体为空实现（pass）</p></li></ul><p>含义：</p><ol><li>父类来确定方法有哪些（预定设计模板）</li><li>具体实现方法由子类自行决定。</li></ol><p><strong>优点：可以提前制定一个指标用来为子类确定设计标准</strong></p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">py的容器基本入门2</summary>
    
    
    
    <category term="py基础" scheme="https://www.lysnowq.cn/categories/py%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="py学习" scheme="https://www.lysnowq.cn/tags/py%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象 (一)</title>
    <link href="https://www.lysnowq.cn/posts/8dd4ca8d.html"/>
    <id>https://www.lysnowq.cn/posts/8dd4ca8d.html</id>
    <published>2023-12-14T15:59:44.735Z</published>
    <updated>2024-09-17T05:42:16.091Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-类和对象的定义使用"><a href="#1-类和对象的定义使用" class="headerlink" title="1. 类和对象的定义使用"></a>1. 类和对象的定义使用</h1><ul><li><p>类的概述：在py中我们使用==class==来设计一个类，而类就类似于设定一个模板或者表格，以便后面可以批量使用同一个模板。而==类可以封装属性==。</p></li><li><p>类的属性：即定义在类中的变量，也叫==成员表变量==。（数据）</p></li><li><p>类的行为：即定义在类中的函数，也叫==成员方法==。（函数）</p></li></ul><p>创建类的基本格式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类的名称</span>：（<span class="keyword">class</span>就是类的标志）</span><br><span class="line">类的属性</span><br><span class="line">    类的行为</span><br></pre></td></tr></table></figure><p>对象可以理解为具体一个物体，当我们使用类构建出对象时，相当于去让一个变量去使用模板。进行编程</p><p>创建类对象的基本方式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象=类()</span><br></pre></td></tr></table></figure><p>即调用类的模板准备使用</p><p>类方法定义：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self,形参<span class="number">1</span>，形参<span class="number">2</span>,...</span>):</span><br><span class="line">方法体</span><br></pre></td></tr></table></figure><p>==注意：在上述类方法定义中，与函数最明显的区别在于，他有一个self，这个self必须填写==</p><p><strong>self:</strong> </p><ol><li><strong>用来表示类对象自身的意思</strong></li><li><strong>要使用类对象调用时，self会自动被py传入</strong></li><li><strong>在方法内部，想要访问成员变量，必须使用self</strong></li><li><strong>在传参时，self可以被忽略，不用理会</strong></li></ol><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment">#类的属性</span></span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    grade=<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#类的行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">putin</span>(<span class="params">self,Name,Age,Grade</span>):</span><br><span class="line">        self.name=Name</span><br><span class="line">        self.age=Age</span><br><span class="line">        self.grade=Grade</span><br><span class="line"><span class="comment">#创建使用对象</span></span><br><span class="line">stu=Student()</span><br><span class="line">stu.putin(Name=<span class="string">&quot;张三&quot;</span>，Age=<span class="number">18</span>,Grade=<span class="number">600</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><hr><h1 id="2-构造方式和魔术方式（统称为内置方法）"><a href="#2-构造方式和魔术方式（统称为内置方法）" class="headerlink" title="2. 构造方式和魔术方式（统称为内置方法）"></a>2. 构造方式和魔术方式（统称为内置方法）</h1><h2 id="2-1-init方法"><a href="#2-1-init方法" class="headerlink" title="2.1 init方法"></a>2.1 init方法</h2><blockquote><p><strong>init方法可以在对象创建时自动执行，并且将传入的参数传递给init使用</strong></p></blockquote><p>基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    类的属性</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,参数<span class="number">1</span>,参数<span class="number">2</span>,...</span>):</span><br><span class="line">        self.属性<span class="number">1</span>=参数<span class="number">1</span></span><br><span class="line">        self.属性<span class="number">2</span>=参数<span class="number">2</span></span><br><span class="line">        .......</span><br><span class="line">        </span><br><span class="line">x=类(参数<span class="number">1</span>,参数<span class="number">2</span>,....)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在上述语法中。我们在构建对象时直接将需要写入的数据写在括号中，此时就可以将值自动放进类的属性中，便于进行操作</p></blockquote><p>==注意：在使用init方法中，我们可以省略属性部分，因为在init方法中，也可以相当于创建了属性中的变量，所以，一但init中引用到的属性，都可以不用在属性中单独定义。==</p><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment">#在init中写了后此处可以不写</span></span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    tender=<span class="literal">None</span></span><br><span class="line">    grade=<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#会自动调用可以直接传参</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,tender,grade</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.tender=tender</span><br><span class="line">        self.age=age</span><br><span class="line">        self.grade=grade</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象数据已重置。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#打印数据行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_information</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.grade,self.age,self.tender)</span><br><span class="line"></span><br><span class="line">stu=Student(<span class="string">&quot;chen&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;667&quot;</span>)</span><br><span class="line">stu.print_information()</span><br></pre></td></tr></table></figure><blockquote><p>上述示例中，我们使用类的行为直接打印出类的属性，免去了不必要的冗杂的代码。使代码更加简洁。</p></blockquote><p>==注意：在类的构建方法中前后的两个下划线不可省略。并且在构建中也需要参数self==</p><h2 id="2-2魔术方法（lt-le-eq-str）"><a href="#2-2魔术方法（lt-le-eq-str）" class="headerlink" title="2.2魔术方法（lt le eq str）"></a>2.2魔术方法（lt le eq str）</h2><blockquote><p>当我们需要对对象中的<strong>数据进行大小比较时无法直接通过对象</strong>进行比较，而魔术方法可以实现这种功能。并且也可以直接通过对象调用输出想要参数。魔术方法有很多，并不仅仅局限于以下介绍的四种。</p></blockquote><h3 id="2-2-1-比较的魔术方法"><a href="#2-2-1-比较的魔术方法" class="headerlink" title="2.2.1 比较的魔术方法"></a>2.2.1 比较的魔术方法</h3><p>首先 lt le eq 三种方法是用来比较大小使用的，区别在于：</p><ol><li>lt仅仅用于大于和小于比较</li><li>le仅仅用于小于等于和大于等于比较</li><li>eq仅仅用于等于比较</li></ol><blockquote><p>==注意：三者是互相独立的，不能混淆，即使用的lt方法中是无法使用等于比较和大于等于以及小于等于。其他的方法同理，一个方法只能负责其支持的单独的功能。<strong>返回值为布尔类型</strong>==</p></blockquote><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">id</span>,price</span>):</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.price=price</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#lt只能小于或者大于，没有等于（le有大于等于和小于等于比较，eq判断等于）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.price&lt;other.price</span><br><span class="line"></span><br><span class="line">car1=Car(<span class="string">&quot;鄂A8888&quot;</span>,<span class="number">20</span>)</span><br><span class="line">car2=Car(<span class="string">&quot;鄂A9999&quot;</span>,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(car2&gt;car1)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231215163450897.png" alt="image-20231215163450897"></p><blockquote><p>比较成功，如果想用&gt;=则需要le，==需要eq</p></blockquote><p>其次探讨str</p><blockquote><p>str是string缩写，目的是让对象可以直接以字符串形式输出</p></blockquote><p>示例（未使用str）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">id</span>,price</span>):</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.price=price</span><br><span class="line"></span><br><span class="line">car=Car(<span class="string">&quot;鄂A8888&quot;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(car.<span class="built_in">id</span>,car.price)</span><br><span class="line"><span class="built_in">print</span>(car)</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231215164305282.png" alt="image-20231215164305282"></p><blockquote><p>其中我们打印内容需要去追溯其中的具体属性。==如果没有str那么返回的是对象的内存地址==。</p></blockquote><p>使用str示例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">id</span>,price</span>):</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.price=price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;车牌为:<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>,价格为:<span class="subst">&#123;self.price&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">car=Car(<span class="string">&quot;鄂A8888&quot;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(car)</span><br></pre></td></tr></table></figure><p>运行结果为:</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231215165216665.png" alt="image-20231215165216665"></p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">py的面向对象概念1</summary>
    
    
    
    <category term="py基础" scheme="https://www.lysnowq.cn/categories/py%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="py学习" scheme="https://www.lysnowq.cn/tags/py%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>py的数据容器</title>
    <link href="https://www.lysnowq.cn/posts/46006cb5.html"/>
    <id>https://www.lysnowq.cn/posts/46006cb5.html</id>
    <published>2023-12-07T08:28:41.933Z</published>
    <updated>2024-09-17T05:35:12.660Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote><p>数据容器的目的是运用少量的彬良存储大量数据，如一个name变量存储多个名字。使变量的运用更加高效。</p><p>数据容器的的概念是：一种额可以容纳多份数据的数据的数据类型，容纳的每份数据称之为一个元素，每一个元素可以说任意 类型的数据类型，如字符串，数字，布尔等。</p></blockquote><p>容器有五类：</p><ol><li>列表（list）</li><li>元组（tuple）</li><li>字符串（str）</li><li>集合（set）</li><li>字典（dirt）</li></ol><p>根据如下特点划分：</p><ul><li>是否支持相同元素</li><li>是否可以修改</li><li>是否有序</li></ul><hr><h1 id="2-列表（list）"><a href="#2-列表（list）" class="headerlink" title="2. 列表（list）"></a>2. 列表（list）</h1><h2 id="2-1-列表基本定义"><a href="#2-1-列表基本定义" class="headerlink" title="2.1 列表基本定义"></a>2.1 列表基本定义</h2><p>基本语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">变量名称=[元素<span class="number">1</span>，元素<span class="number">2</span>，...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义空列表</span></span><br><span class="line">变量名=[]</span><br><span class="line">变量名=<span class="built_in">list</span>()</span><br></pre></td></tr></table></figure><ul><li><strong>列表的标志为[]</strong></li><li><strong>列表的每一个元素用逗号隔开</strong></li><li><strong>空列表的定义中list定义时用小括号而非中括号</strong></li></ul><p>示例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list=[<span class="string">&quot;吃喝不愁&quot;</span>，<span class="number">987</span>，<span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231207160851648.png" alt="image-20231207160851648"></p><p>类型为list（列表）类型</p><p>列表的元素不仅可以用来存储常规数据，也可以存储另一个列表，即列表的嵌套。</p><p>格式如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表名称=[列表<span class="number">1</span>,列表<span class="number">2</span>,列表<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">my_list1=[[<span class="number">112</span>,<span class="number">3423</span>,<span class="number">54</span>],[<span class="string">&quot;akfjh&quot;</span>,<span class="string">&quot;sdkaj&quot;</span>,<span class="string">&quot;aksjd&quot;</span>]]</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">list1=[<span class="number">123</span>,<span class="number">543</span>,<span class="number">12</span>]</span><br><span class="line">list2=[<span class="string">&quot;aksud&quot;</span>,<span class="string">&quot;iasjudh&quot;</span>,<span class="string">&quot;skajd&quot;</span>]</span><br><span class="line">my_list2=[list1,list2]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(my_list1)</span><br><span class="line">    <span class="built_in">print</span>(my_list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(my_list1),<span class="built_in">type</span>(my_list2))</span><br></pre></td></tr></table></figure><p>输出结果为</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231207161656361.png" alt="image-20231207161656361"></p><hr><h2 id="2-2-常用操作"><a href="#2-2-常用操作" class="headerlink" title="2.2 常用操作"></a>2.2 常用操作</h2><p>列表的取出可以使用下标索引</p><p>基本语法为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表名称[元素下标]</span><br></pre></td></tr></table></figure><ul><li><strong>在这里元素下标第一个从0开始，依次往后推，如果从后往前从-1开始</strong></li><li><strong>如果是嵌套列表则用两个[]</strong></li></ul><p>示例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">my_list1=[<span class="string">&quot;吃喝不愁&quot;</span>，<span class="number">987</span>，<span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个元素为<span class="subst">&#123;my_list1[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个元素倒序为<span class="subst">&#123;my_list1[-<span class="number">3</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">list1=[<span class="number">123</span>,<span class="number">543</span>,<span class="number">12</span>]</span><br><span class="line">list2=[<span class="string">&quot;aksud&quot;</span>,<span class="string">&quot;iasjudh&quot;</span>,<span class="string">&quot;skajd&quot;</span>]</span><br><span class="line">my_list2=[list1,list2]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个子列表的第二个元素为<span class="subst">&#123;my_list2[<span class="number">0</span>][<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>基本操作如下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">使用方式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">名称.append(元素)</td><td style="text-align:center">向列表中添加一个元素</td></tr><tr><td style="text-align:center">名称.extend(容器)</td><td style="text-align:center">将目标容器的元素取出追加到列表的末尾</td></tr><tr><td style="text-align:center">名称.insert(下标,元素)</td><td style="text-align:center">在指定下标处插入指定元素，原指定下标元素及其以后的元素编号+1</td></tr><tr><td style="text-align:center">del 名称[下标]</td><td style="text-align:center">删除列表指定下标元素</td></tr><tr><td style="text-align:center">名称.pop(下标)</td><td style="text-align:center">删除下标指定元素并且返回</td></tr><tr><td style="text-align:center">名称.remove(元素)</td><td style="text-align:center">从前向后删除第一个与之匹配的元素</td></tr><tr><td style="text-align:center">名称.clear()</td><td style="text-align:center">清空此列表</td></tr><tr><td style="text-align:center">名称.count(元素)</td><td style="text-align:center">统计这个元素在列表中出现次数</td></tr><tr><td style="text-align:center">名称.index()</td><td style="text-align:center">查找指定元素下标位置，如果没有就报错ValueError</td></tr><tr><td style="text-align:center">len（名称）</td><td style="text-align:center">统计列表内有多少元素</td></tr></tbody></table></div><hr><h1 id="3-元组（tuple）"><a href="#3-元组（tuple）" class="headerlink" title="3. 元组（tuple）"></a>3. 元组（tuple）</h1><h2 id="3-1-元组基本定义"><a href="#3-1-元组基本定义" class="headerlink" title="3.1 元组基本定义"></a>3.1 元组基本定义</h2><blockquote><p>元组与列表区别在于不可修改。定义后只读。</p><p>当我们封装的数据不想让其被修改则用元组</p></blockquote><p>基本语法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">(元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,....)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">变量名称=(元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,....)</span><br><span class="line"><span class="comment">#定义空元组</span></span><br><span class="line">变量名称=()</span><br><span class="line">变量名称=<span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure><ul><li><p><strong>元组在定义上与列表是括号的不同，元组也支持不同数据类型混搭</strong></p></li><li><p><strong>空元组两种方式均用小括号</strong></p></li></ul><p>元组不可以修改，但是如果元组中包含列表，则列表对应内容可以修改</p><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">my_tuple=(<span class="number">123</span>,<span class="number">453</span>,[<span class="number">123</span>,<span class="number">432</span>])</span><br><span class="line"><span class="keyword">del</span> my_tuple[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_tuple)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">43</span>,<span class="number">12</span>]</span><br><span class="line">my_tuple2=(<span class="built_in">list</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="string">&quot;tu&quot;</span>)</span><br><span class="line">my_tuple2[<span class="number">0</span>].append(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple2)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208153918364.png" alt="image-20231208153918364"></p><hr><h2 id="3-2-元组常规操作"><a href="#3-2-元组常规操作" class="headerlink" title="3.2 元组常规操作"></a>3.2 元组常规操作</h2><p>元组由于其不可修改特性，所以具有操作的方式如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">使用方式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">名称.index(元素)</td><td style="text-align:center">查找某个元素下标</td></tr><tr><td style="text-align:center">名称.count(元素)</td><td style="text-align:center">统计某个元素出现次数</td></tr><tr><td style="text-align:center">len(元组)</td><td style="text-align:center">统计元组有多少元素</td></tr></tbody></table></div><hr><h1 id="4-字符串及其操作（str）"><a href="#4-字符串及其操作（str）" class="headerlink" title="4. 字符串及其操作（str）"></a>4. 字符串及其操作（str）</h1><p>字符串的本质为一个容器，并且不可修改。</p><p><strong><em>但是字符串拥有替换功能（replace）</em></strong></p><p>基本语法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.replace(字符串<span class="number">1</span>，字符串<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其功能为将字符串1内容换为字符串2内容。从而==得到一个新的字符串==</p><p>示例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_st=<span class="string">&quot;you and me&quot;</span></span><br><span class="line">new_st=my_st.replace(<span class="string">&quot;me&quot;</span>,<span class="string">&quot;him&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_st)</span><br><span class="line"><span class="built_in">print</span>(new_st)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="C:/Users/LYsnowQ/AppData/Roaming/Typora/typora-user-images/image-20231208155759283.png" alt="image-20231208155759283"></p><p>原字符串并未改变</p><p><strong><em>字符串还可以进行分割（split）</em></strong></p><p>基本语法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.split(分割字符串)</span><br></pre></td></tr></table></figure><p>功能：将字符串分割成多个字符串</p><p>==将会得到一个列表，而字符串本体不变==</p><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;hello you and me&quot;</span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>)<span class="comment">#这里我们将有空格的地方分开</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208172800281.png" alt="image-20231208172800281"></p><p><strong><em>字符串的整规功能(strip)</em></strong></p><p>基本语法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.strip(字符串)<span class="comment">#若不填则默认为空格</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_str1=<span class="string">&quot; hello &quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_str1.strip())</span><br><span class="line">my_str2=<span class="string">&quot;1221hello221&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_str2.strip(<span class="string">&quot;122&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208173504300.png" alt="image-20231208173504300"></p><p><strong><em>字符串也可以进行count和len的功能</em></strong></p><p><strong><em>字符串的另一个特性：切片（列表和元组均支持）：</em></strong></p><p>基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列[开始元素下标：结束元素下标：步长]</span><br></pre></td></tr></table></figure><p>在这个语法中需要注意的是：</p><ul><li><strong>起始和结束都可以省略，表示从头开始直到结尾，步长空着默认为1</strong></li><li><strong>步长为1为一个一个取，为2则取一个跳过一个，如果为负数则倒着取</strong></li><li><strong>结束时不包含结束元素下标</strong></li><li><strong>开始元素和结束元素可以取负</strong></li></ul><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;爱党爱国爱人民&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>:<span class="number">6</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">3</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:-<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208174433051.png" alt="image-20231208174433051"></p><h1 id="5-集合（set）"><a href="#5-集合（set）" class="headerlink" title="5. 集合（set）"></a>5. 集合（set）</h1><p>集合特点：</p><ul><li>没有重复元素（即使录入了输出时也只会留下一个）</li><li>无序（不支持下标索引）</li></ul><p>基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">集合名称=&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">集合名称=()</span><br></pre></td></tr></table></figure><p>示例集合的基础使用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#集合添加元素</span></span><br><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">my_set1.add(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机取出(移除一个元素)</span></span><br><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">ele=my_set1.pop()</span><br><span class="line"><span class="built_in">print</span>(ele)</span><br><span class="line"></span><br><span class="line"><span class="comment">#移除元素</span></span><br><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">ele2=my_set1.remove(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#清空集合</span></span><br><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">my_set1.clear()</span><br><span class="line"><span class="built_in">print</span>(my_set1)</span><br></pre></td></tr></table></figure><p><strong><em>集合的差集：重新得到一个集合，集合1有而集合2没有的元素组成的集合</em></strong></p><p>基本语法如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合<span class="number">1.</span>difference(集合<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">my_set2=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">123</span>&#125;</span><br><span class="line">dif=my_set1.difference(my_set2)</span><br><span class="line"><span class="built_in">print</span>(dif)</span><br></pre></td></tr></table></figure><p><strong><em>消除差集：在集合1内删除集合2的内容</em></strong></p><p>基本语句如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合<span class="number">1.</span>difference_update(集合<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">my_set2=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">123</span>&#125;</span><br><span class="line">my_set1.difference_update(my_set2)</span><br><span class="line"><span class="built_in">print</span>(my_set1)</span><br></pre></td></tr></table></figure><p><strong><em>集合合并：将两个集合合并为一个</em></strong></p><p>基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合<span class="number">1.</span>union(集合<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_set1=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">4532</span>,<span class="number">123</span>&#125;</span><br><span class="line">my_set2=&#123;<span class="number">12</span>,<span class="number">345</span>,<span class="number">123</span>,<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">my_set3=my_set1.union(my_set2)</span><br><span class="line"><span class="built_in">print</span>(my_set3)</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><strong>集合的添加元素使用add</strong></li><li><strong>集合的差集时得到一个新集合并非改变原集合</strong></li><li><strong>消除差集则是修改了集合1内容，没有改变集合2内容</strong></li><li><strong>集合合并后相同元素会只存在一个被保留</strong></li></ol><hr><h1 id="6-字典（dirt）"><a href="#6-字典（dirt）" class="headerlink" title="6. 字典（dirt）"></a>6. 字典（dirt）</h1><p>字典的功能是存储键值对，通过key找值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">&#123;key1:value1,key2:value,key3:value&#125;</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">字典名=&#123;key1:value1,key2:value,key3:value&#125;</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">字典名称=&#123;&#125;</span><br><span class="line">字典名称=<span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p>==<strong>注意：字典的key值不能重复，value可以重复</strong>==</p><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dirt=&#123;<span class="string">&quot;张三&quot;</span>:<span class="number">13</span>,<span class="string">&quot;李四&quot;</span>:<span class="number">14</span>,<span class="string">&quot;王五&quot;</span>:<span class="number">15</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_dirt[<span class="string">&quot;张三&quot;</span>])</span><br></pre></td></tr></table></figure><p><strong><em>字点新增元素和改变value</em></strong></p><p>基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dirt=&#123;key1:value1,key2:value,key3:value&#125;</span><br><span class="line">my_dirt[key]=value0</span><br></pre></td></tr></table></figure><p>==当key已经存在于字典时则是修改value==</p><p>==如果 不存在key则相当于添加键值对==</p><p><strong><em>字典删除和清空：</em></strong></p><p>删除基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典.pop(key)</span><br></pre></td></tr></table></figure><p>==<strong>将key对应的value取出，同时字典被修改，对应键值对被删除</strong>==</p><p>清空基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典.clear()</span><br></pre></td></tr></table></figure><p><strong><em>字典获取全部key</em></strong></p><p>基本语法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典.keys()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_dirt=&#123;<span class="string">&quot;张三&quot;</span>:<span class="number">13</span>,<span class="string">&quot;李四&quot;</span>:<span class="number">14</span>,<span class="string">&quot;王五&quot;</span>:<span class="number">15</span>&#125;</span><br><span class="line">keys=my_dirt.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208182456728.png" alt="image-20231208182456728"></p><p><strong><em>字典的遍历</em></strong></p><p>字典低遍历结果是显示key值，如果需要显示value值需要使用dirt[key]</p><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_dirt=&#123;<span class="string">&quot;张三&quot;</span>:<span class="number">13</span>,<span class="string">&quot;李四&quot;</span>:<span class="number">14</span>,<span class="string">&quot;王五&quot;</span>:<span class="number">15</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dirt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;字典key为<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;字典value为<span class="subst">&#123;my_dirt[key]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208182958321.png" alt="image-20231208182958321"></p><p><strong>字典也支持使用len函数统计数量</strong></p><hr><h1 id="7-容器通用操作"><a href="#7-容器通用操作" class="headerlink" title="7. 容器通用操作"></a>7. 容器通用操作</h1><p><strong><em>max（容器）：找到容器中最大的值</em></strong></p><p><strong><em>min（容器）：找到到容器中最小值</em></strong></p><p><strong><em>list（容器）：将容器转化为列表</em></strong></p><p><strong><em>tuple（容器）：将容器转化为元组</em></strong></p><p><strong><em>str（容器）：将容器转化为字符串</em></strong></p><p><strong><em>sorted（容器,[reverse=Ture]）(中括号为是否开起倒序排序,中括号使用时去掉)：排序</em></strong></p><p>示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example=<span class="string">&quot;123 aksdfkdj 12987&quot;</span></span><br><span class="line">my_dirt=&#123;<span class="string">&quot;张三&quot;</span>:<span class="number">13</span>,<span class="string">&quot;李四&quot;</span>:<span class="number">14</span>,<span class="string">&quot;王五&quot;</span>:<span class="number">15</span>&#125;</span><br><span class="line">list2=<span class="built_in">list</span>(my_dirt)</span><br><span class="line">list1=<span class="built_in">list</span>(example)</span><br><span class="line">tuple1=<span class="built_in">tuple</span>(example)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(my_dirt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(example))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(example,reverse=Ture)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231208185035639.png" alt="image-20231208185035639"></p><p>==<strong>注意：字典转化后只剩key，字符串转化后每个字符都被单独分出来了，在排序中字典也会丢失value</strong>==</p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">py的容器基本入门</summary>
    
    
    
    <category term="py基础" scheme="https://www.lysnowq.cn/categories/py%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="py学习" scheme="https://www.lysnowq.cn/tags/py%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++基础学习及与C语言的对比分析</title>
    <link href="https://www.lysnowq.cn/posts/fc0b9602.html"/>
    <id>https://www.lysnowq.cn/posts/fc0b9602.html</id>
    <published>2023-11-30T07:31:32.301Z</published>
    <updated>2024-09-17T05:30:04.921Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-c-的空间开辟和释放"><a href="#1-c-的空间开辟和释放" class="headerlink" title="1 c++的空间开辟和释放"></a>1 c++的空间开辟和释放</h1><h2 id="1-1-c-的空间开辟"><a href="#1-1-c-的空间开辟" class="headerlink" title="1.1 c++的空间开辟"></a>1.1 c++的空间开辟</h2><p>C++中开辟空间不同于c语言。他为我们提供了更加便利的空间开辟方式——new运算符。</p><p>基本格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>上述代码意思是开辟一块10个空间为整数存放。==注意：这里是开辟10个字节的整形空间，可以理解为开始10个字节空间是存储整形的，并非10个整形空间==</p><p>而在c语言中是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相比之下，c++对其代码和结构做了更多优化。</p><p>那么开辟10个整形空间大小就用如下方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p=<span class="keyword">new</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这里就开辟了10个整形大小空间，即10<em>4个字节大小。<em>*(开辟了一个数组)</em></em></p><p>在c语言中是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p=(<span class="type">int</span>*)mallooc(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>==注意：如果开辟10个字节我们用的是”（）“小括号，如果是10个整形空间，我们就用的是“”[]”中括号==</p><p>c++中仿照数组的命名形式将其优化，使得代码更加高效。</p><hr><h2 id="1-2-c-的空间释放"><a href="#1-2-c-的空间释放" class="headerlink" title="1.2 c++的空间释放"></a>1.2 c++的空间释放</h2><p>在空间的释放中，c与c++也有着不同之处</p><p>c++的空间如果是第一种用int（10）声明的那么释放如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>c语言中如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span> (p);</span><br></pre></td></tr></table></figure><p>如果是c++中声明了一个数组则是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure><p>==注意：这里则是在其中加一个中括号才可以完全释放数组，否则只会释放首元素的地址空间==</p><p>在c语言中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p>依旧是如此就可以了。</p><p><strong>那么这里我们可以理解为c语言中只是进行了一个地址分配了4*10个空间，而c++中则是分配了10个int类型的地址空间。</strong></p><p><strong>c语言中，目前只有c99标准可以使用动态参数定义数组，否则就需要用malloc申请动态空间去定义自定义数组。</strong>c++对其进行了优化。</p><hr><h1 id="2-c-的引用"><a href="#2-c-的引用" class="headerlink" title="2. c++的引用"></a>2. c++的引用</h1><p>在c++中有个引用的方式，可以理解为为一个空间起多个变量名字，基本格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure><p>此时就完成了引用。那么当我们输出b和a时如下</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231130164320509.png" alt="image-20231130164320509"></p><p>那么这里与直接将a的值赋值给b有什么区别呢？我们说这里我们是给a的地址起了个别名，就意味着，我们对b的操作是可以影响到a的。看以下示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line"></span><br><span class="line">b=<span class="number">20</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a的值为：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b的值为：&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231130164607558.png" alt="image-20231130164607558"></p><p>我们可以发现，b的操作可以影响到a。所以与a直接赋值给b是有区别的。这里对b的赋值操作直接影响了a。</p><p><strong>在使用引用时要注意以下几点：</strong></p><ol><li><strong>引用必须初始化，即声明时就要将其赋值。</strong></li><li><strong>引用初始化后不可改变（我们可以看见b=20时只是改变了地址对应的空间存储的值）。</strong></li><li><strong>引用时不可以用数值直接赋值（常量引用可以）。</strong></li><li><strong>在引用函数中，不要将局部变量返回出来（因为函数中的局部变量在函数结束时会销毁）</strong></li></ol><p><strong>引用的本质：</strong></p><p>​    <strong>引用实际上是常量指针的形式，也就解释了为什么引用的操作可以影响原空间并且引用初始化后不可以更改引用的对象了。</strong></p><p>在上述例子中我们可以有如下分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;b=a;<span class="comment">//这里即为int* const b=&amp;a;</span></span><br><span class="line">b=<span class="number">20</span>;<span class="comment">//可以理解为 *b=20;</span></span><br></pre></td></tr></table></figure><p><strong>那么在函数中，引用的作用是方便修改实参。优点在于简化了指针修改实参。</strong></p><p>引用中也有常量引用，即用const修饰，==常量引用最大的作用是防止误操作，因为引用会对原数据造成修改，在引用时需要保护起来，一半用于函数的参数传递，防止修改了其值。==</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b的值为：&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">14</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    <span class="built_in">print</span>(&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还有另一种用法const修饰的引用可以直接使用赋值</p><p>示例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b的值为：&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出结果为</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231130171534435.png" alt="image-20231130171534435"></p><p>其原理可以拆成如下方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//分为两步</span></span><br><span class="line"><span class="comment">//第一步，系统会自动创建一个变量int temp=10（名字我们不知道，temp只是做举例）</span></span><br><span class="line"><span class="comment">//第二步，系统再执行const int &amp;b=temp;</span></span><br></pre></td></tr></table></figure><hr><h1 id="3-c-函数及其用法"><a href="#3-c-函数及其用法" class="headerlink" title="3. c++函数及其用法"></a>3. c++函数及其用法</h1><h2 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h2><p>在c++中的函数是有默认参数的</p><p>下面为例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">20</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a+b=&quot;</span>&lt;&lt;<span class="built_in">add</span>(<span class="number">10</span>)&lt;&lt;endl;<span class="comment">//第一个输出</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a+b=&quot;</span>&lt;&lt;<span class="built_in">add</span>(<span class="number">10</span>,<span class="number">40</span>)&lt;&lt;endl;<span class="comment">//第二个输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>将b直接赋值，在调用用函数时只传进去一个数，那么他就会默认给形参a赋值。(第一个输出)，然后20就是b的默认参数</p></li><li><p>那么当我们传入两个数值时40便会覆盖b的20（第二个输出）。</p></li></ul><p><strong>注意：</strong></p><ol><li><strong>当我们设置了默认参数后，此参数以后的参数都必须设置默认参数</strong></li><li><strong>默认参数在声明和函数定义时只能设置一次，即声明和定义中只能有一个有默认参数。</strong></li></ol><hr><h2 id="3-2-函数的占位参数"><a href="#3-2-函数的占位参数" class="headerlink" title="3.2 函数的占位参数"></a>3.2 函数的占位参数</h2><p>c++中函数可有有占位参数，用来占位使用。</p><p>基本语法结构为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span></span>&#123;<span class="comment">//此处第二个参数只有类型的为占位参数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且占位参数也可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> = <span class="number">10</span>)</span></span>&#123;<span class="comment">//此处第二个参数只有类型的为占位参数并且不需要名字直接可以赋值默认值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：默认参数调用时必须传入数据</strong></p><hr><h2 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h2><p>即函数名可以相同（c语言不具备此重要性质）</p><p>优点：可以提高复用性</p><p>函数重载条件：</p><ol><li>同一个作用域下。</li><li>函数名称相同</li><li>函数参数的 <strong>类型不同</strong> 或者 <strong>个数不同</strong>或者 <strong>顺序不同</strong></li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">float</span> a)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用参数的函数示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;a)</span></span>&#123;<span class="comment">//调用此参数时需要传入变量名</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;<span class="comment">//调用此函数时需要直接传入数值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==<strong>注意：函数重载时尽量不要写默认参数，不然容易出现歧义。</strong>==</p><p>如下==<strong>反例</strong>==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;this is a text&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上当我们只传递一个数值时会分不清使用哪个函数，所以会报错。<strong>（但是如果传入两个值会执行第一个函数）</strong></p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">从c到c++的一些基本衔接</summary>
    
    
    
    <category term="c++基础" scheme="https://www.lysnowq.cn/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++学习" scheme="https://www.lysnowq.cn/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>文件操作</title>
    <link href="https://www.lysnowq.cn/posts/95495db.html"/>
    <id>https://www.lysnowq.cn/posts/95495db.html</id>
    <published>2023-11-24T02:52:00.331Z</published>
    <updated>2024-09-22T15:44:17.299Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>文件分为两种：</p><ol><li>磁盘文件：指一组有关数据的有序集合，通常存储在外部介质（如硬盘）上，使用时才调入内存。</li><li>设备文件：设备文件：操作系统中，把每个与主机相连的的输入输出设备看作一个文件，把他们的输入输出作为磁盘的读写。</li></ol><p>磁盘文件分类：</p><ol><li>文本文件：基于字符编码的文件，可以用文本编辑器直接打开，并且数以ASCII编码形式存在。</li><li>二进制文件：基于值编码文件，数字的存储以二进制形式，内存中数据按照在内存中的原样输出到磁盘。</li></ol><p>除了文本文件其他的基本都是二进制文件。（如图片，音频等）</p><hr><h1 id="2-文件的打开关闭"><a href="#2-文件的打开关闭" class="headerlink" title="2. 文件的打开关闭"></a>2. 文件的打开关闭</h1><p>文件指针：用指针指向文件的指针。（FLIE*）</p><p><strong>当打开文件时文件会放在缓冲区中。</strong></p><p>打开文件的函数：fopen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE*P=fopen(<span class="string">&quot;文件地址&quot;</span>，读取方式)；<span class="comment">//路径地址用“/”</span></span><br></pre></td></tr></table></figure><p>读取方式有以下几种：</p><div class="table-container"><table><thead><tr><th>打开模式</th><th>意义</th></tr></thead><tbody><tr><td>r/rb</td><td>以只读方式打开一个文件（不会自动创建文件，如果不存在文件就会报错）</td></tr><tr><td>w\wb</td><td>以写的方式打开文件（如果文件不存在，系统就会创建一个文件，如果文件有内容，则会覆盖原内容）</td></tr><tr><td>a/ab</td><td>以追加方式打开文件，在末尾添加内容（如果不存在，系统会自动创建一个文件）</td></tr><tr><td>r+/rb+</td><td>以可读可写的方式打开文件（不会创建新文件）</td></tr><tr><td>w+/wb+</td><td>以可读可写的方式i打开一个文件（如果文件存在就会覆盖原文件内容，文件不存在则创建一个文件）</td></tr><tr><td>a+/ab+</td><td>以添加方式打开文件，在文件末尾更改（如果文件不存在则会创建一个文件）</td></tr></tbody></table></div><p>在文件打开后我们应该将文件关闭。使用fclose函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE*p)</span>;</span><br><span class="line"><span class="comment">//如果成功，则会返回0，如果失败则会返回-1</span></span><br></pre></td></tr></table></figure><ul><li>一个程序进程能打开的文件是有限制的。</li><li>如果文件未关闭，那么操作系统会在进程结束后统一关闭</li></ul><p>读取出错原因可能有：</p><ol><li>找不到文件（路径有误）。</li><li>文件权限限制。</li><li>文件同时打开个数上限。（最多65535个）</li></ol><hr><h1 id="3-文件的读写"><a href="#3-文件的读写" class="headerlink" title="3. 文件的读写"></a>3. 文件的读写</h1><h2 id="文件读取："><a href="#文件读取：" class="headerlink" title="文件读取："></a>文件读取：</h2><p>我们在读写字符文件时使用fgetc和fputc函数用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(文件指针)</span>;</span><br></pre></td></tr></table></figure><p>成功时会返回读取到的字符，失败为-1；</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们创建了个txt文本文件，里面写了个A</span></span><br><span class="line"></span><br><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch=fgetc(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch);</span><br></pre></td></tr></table></figure><p>最后输出结果为A</p><p>注意：</p><blockquote><p><strong>那当我们输出字符串时不需要对指针进行移动，因为 在文件读取中，其中的光标在读取完文件一个字符后会自动往前进一格。所以只需要循环就行了。并且修改文件指针会出错，所以不能修改文件指针。 在文件结尾默认是-1，原因是在文本文件中是以ASCII码存储，都为正，汉字虽然是负数名单时-1不表示汉字。所以结尾为-1。并且文件结尾使用EOF表示==（以上规则只适用于文本文件）==，一般在文件开头就用define定义EOF为-1。</strong></p><p><strong>如果为二进制文件则可以使用feof函数判断文件是否结束，并且feof函数既可以判断二进制文件也可以判断文本文件。当到文件结尾时返回值为非0数，没到时为0（判断的时最后一次读取操作）</strong></p></blockquote><hr><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>文件写入时我们在文件打开方式中应该先换为w。</p><p>写入用fputc函数格式为</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputc</span>(字符,文件指针);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">fputc(ch);</span><br><span class="line">fclose(p);</span><br></pre></td></tr></table></figure><p>在文件写入中出错概率比单纯读取文件出错概率小，在文件损坏或文件的路径有误时文件会被直接创建，所以写入文件出错一般为：</p><pre><code>1. 文件打开上限。1. 文件的权限限制</code></pre><p>在写入过程中，如果问我们加上循环就可以在文件里编写大量文段</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE*p1=fopen(<span class="string">&quot;D:/Desktop/a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=fgetc(p))!=EOF)&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    fputc(ch,p);</span><br><span class="line">&#125;</span><br><span class="line">fclose(p);</span><br></pre></td></tr></table></figure><hr><h1 id="4-文件的加密解密"><a href="#4-文件的加密解密" class="headerlink" title="4. 文件的加密解密"></a>4. 文件的加密解密</h1><p>文件加密解密的基本原理时基于字符由ASCII码存储，所以，我们在输入狗移动字符对应的数字即可改变内容，在解密时以相同的方式相反移动同样的大小就能恢复。</p><p>例子：</p><p>（A.txt用来显示正常文件，a.txt用来显示加密文件）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EOF -1</span></span><br><span class="line"></span><br><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE*p1=fopen(<span class="string">&quot;D:/Desktop/a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=fgetc(p)) != EOF)&#123;</span><br><span class="line"> ch++;</span><br><span class="line">    fputc(ch,p1);</span><br><span class="line">&#125;</span><br><span class="line">fclose(p);</span><br><span class="line">fclose(p1);</span><br></pre></td></tr></table></figure><p>这时我们会得到一份a.txt文件即为加密后的文件，如果相对a.txt文件解密，只需要在加密基础上倒过来ch—就可以了。</p><hr><h1 id="5-文件行的读写"><a href="#5-文件行的读写" class="headerlink" title="5. 文件行的读写"></a>5. 文件行的读写</h1><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>我们使用fgetc进行文件行的读取</p><p>基本格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(字符串指针,最大长度,文件指针)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pp=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);</span><br><span class="line"><span class="built_in">memset</span>(pp,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">fgets(pp,<span class="number">100</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">free</span>(pp);</span><br><span class="line">fclose(p);</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>在操作中，==我们设定的大小中会预留一个位置存储“\0”,即我们设置的为100个位置，有效字符位置只有99个==。当读取到换行时，会自动换行，并且会结束读取 。在一轮读取后下次读取时依旧会以现在的位置继续读取，即光标会自动移到下一位。</strong></p><p>循环读取示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pp=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);</span><br><span class="line"><span class="keyword">while</span>(!feof(p))<span class="comment">//当文件到了结尾返回0，没到时返回为非0值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pp,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">fgets(pp,<span class="number">100</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(pp);</span><br><span class="line">fclose(p);</span><br></pre></td></tr></table></figure><p>上述代码中每次我们都会执行一次memset是为了防止上次读取污染本次读取。</p><hr><h2 id="文件写入-1"><a href="#文件写入-1" class="headerlink" title="文件写入"></a>文件写入</h2><p>我们使用fputs进行行写入</p><p>基本格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>（常量字符串,文件指针）;</span><br></pre></td></tr></table></figure><p>当fputs在字符串中遇到\n时也会进行换行操作，遇到\0直接停止。</p><p>示例演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ch[]=<span class="string">&quot;这是一个测试&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(ch,p);</span><br><span class="line">fclose(p);</span><br></pre></td></tr></table></figure><p>连续的输入如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FILE*p=fopen(<span class="string">&quot;D:/Desktop/A.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>*pp=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>,pp);<span class="comment">//接收除了换行以外的所有输入</span></span><br><span class="line">    getchar();<span class="comment">//防止打完第一行后卡住无法换行</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p,<span class="string">&quot;cmd=exit&quot;</span>)<span class="comment">//也可使用strncmp(p,&quot;cmd=exit&quot;,8))</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    stract(pp,<span class="string">&quot;\n&quot;</span>);<span class="comment">//追加换行符</span></span><br><span class="line">    <span class="built_in">fputs</span>(pp,p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">c语言的文本基础操作</summary>
    
    
    
    <category term="c基础" scheme="https://www.lysnowq.cn/categories/c%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c学习" scheme="https://www.lysnowq.cn/tags/c%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://www.lysnowq.cn/posts/7b216a3b.html"/>
    <id>https://www.lysnowq.cn/posts/7b216a3b.html</id>
    <published>2023-11-20T03:56:21.829Z</published>
    <updated>2024-09-17T05:39:37.084Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h1><p>树：</p><ul><li>树是一个n个结点的有限集，如果n=0称之为空树。</li><li>树的定义是递归的，树中又调用了自身。</li><li>树的根节点没有前驱，除了根节点，其他所有节点有且只有一个前驱</li><li>树中所有节点可以有0个或者多个后驱。</li></ul><p>二叉树：</p><ul><li><p>特殊的树结构</p></li><li><p>每个结点至多只有两个子树</p></li></ul><p>遍历方式：</p><ul><li>前中后 根节点遍历</li></ul><p>前序：根-&gt;左-&gt;右</p><p>中序：左-&gt;根-&gt;右</p><p>后序：左-&gt;右-&gt;根</p><p>如图所示：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231120123206399.png" alt="image-20231120123206399"></p><p>在这里需要注意的是，根是相对的，左右也是相对的，以A为根，左右为B,C。以B为根，左右为D，F。</p><ul><li>前序时，开始根为A然后是A-B-D,此时根为B，所以退出D进入E。</li><li>中序时，开始从D开始，然后根为B，所以是D-B-E,然后退出E进入A。</li><li>后序时，开始从D开始，然后去E，再去根B，然后进入F-G-C最后到A。</li></ul><h1 id="2-树的创建"><a href="#2-树的创建" class="headerlink" title="2. 树的创建"></a>2. 树的创建</h1><p>树的创建中我们每次都会调用相同的结构体，所以我们使用递归来重复定义和写入预设代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREECREAT</span> &#123;</span></span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREECREAT</span>* <span class="title">LEFT</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREECREAT</span>* <span class="title">RIGHT</span>;</span></span><br><span class="line">&#125;TREE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TREERE</span><span class="params">(TREE** t)</span> &#123;</span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line"><span class="comment">//name = getchar();</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;name);</span><br><span class="line"><span class="keyword">if</span> (name==<span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//此时为空节点</span></span><br><span class="line">*t = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//此时不为空</span></span><br><span class="line">*t = (TREE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TREE));</span><br><span class="line">(*t)-&gt;name = name;</span><br><span class="line"><span class="comment">//左子树</span></span><br><span class="line">TREERE(&amp;((*t)-&gt;LEFT));</span><br><span class="line"><span class="comment">//右子树</span></span><br><span class="line">TREERE(&amp;((*t)-&gt;RIGHT));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">TREE* t ;</span><br><span class="line">TREERE(&amp;t);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上述过程中，我们将结构重复使用，避免了每次定义的繁杂过程。我们传入二级指针来修改指向。这时我们的录入得到顺序为根-&gt;左-&gt;右，并且是层级递增。如果需要先录入右侧，只需要更改两条代码的位置即可。</p><h1 id="3-树的遍历"><a href="#3-树的遍历" class="headerlink" title="3.树的遍历"></a>3.树的遍历</h1><h2 id="3-1普通遍历"><a href="#3-1普通遍历" class="headerlink" title="3.1普通遍历"></a>3.1普通遍历</h2><p>树的遍历有前序，中序，后续三种。其区别并不大==仅仅需要改变代码优先执行的顺序即可==</p><p>前序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printtree1</span><span class="params">(TREE* p)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//前序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, p-&gt;name);</span><br><span class="line">printtree1(p-&gt;LEFT);</span><br><span class="line">printtree1(p-&gt;RIGHT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printtree2</span><span class="params">(TREE* p)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line">printtree2(p-&gt;LEFT);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, p-&gt;name);</span><br><span class="line">printtree2(p-&gt;RIGHT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printtree3</span><span class="params">(TREE* p)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line">printtree3(p-&gt;LEFT);</span><br><span class="line">printtree3(p-&gt;RIGHT);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, p-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其本质在于printf的位置，即根的输出与左右分枝的执行顺序。</p><h2 id="3-2-层次遍历"><a href="#3-2-层次遍历" class="headerlink" title="3.2 层次遍历"></a>3.2 层次遍历</h2><p>层次遍历相当于树的同级结构的遍历，如图：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231120123206399.png" alt="image-20231120123206399"></p><p>层次遍历就相当于是A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G的顺序进行遍历，这里b和c是同一级，defg为同一级。这里由于我们用递归定义的树结构，这里层级遍历就需要用到队的结构去实现。</p><p>由于层次遍历，我们可以改变一下录入规则去使用它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树模块</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;TREE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列模块</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUEUE</span> &#123;</span></span><br><span class="line">TREE* arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> bottom;<span class="comment">//用整形计数</span></span><br><span class="line">&#125;QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initqueue</span><span class="params">(QUEUE* q)</span> &#123;</span><br><span class="line">(*q).front = (*q).bottom = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(QUEUE* q1, TREE* p2)</span> &#123;</span><br><span class="line">(*q1).arr[(*q1).front++] = p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TREE* <span class="title function_">pop</span><span class="params">(QUEUE* q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*q).front == (*q).bottom)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ((*q).arr[(*q).bottom++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配是否符合条件</span></span><br><span class="line">TREE* <span class="title function_">search</span><span class="params">(TREE* tr)</span> &#123;</span><br><span class="line">QUEUE* q;</span><br><span class="line">TREE* p;</span><br><span class="line">initqueue(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (tr-&gt;left == <span class="literal">NULL</span> || tr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> tr;</span><br><span class="line">&#125;</span><br><span class="line">put(&amp;q, tr);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">p = pop(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">put(&amp;q, p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">putqueue(&amp;q, p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化树</span></span><br><span class="line">TREE* <span class="title function_">inittree</span><span class="params">(TREE**p)</span> &#123;</span><br><span class="line">TREE* pp = *p;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;data);</span><br><span class="line">pp = (TREE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TREE));</span><br><span class="line">pp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">pp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pp-&gt;data = data;</span><br><span class="line">*p = pp;</span><br><span class="line"><span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">TREE* p, * q;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">q = (TREE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TREE));</span><br><span class="line">q-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入节点字母：\n&quot;</span>);</span><br><span class="line">ch = getchar();</span><br><span class="line">q-&gt;data = ch;</span><br><span class="line">p = search(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">p-&gt;left = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p-&gt;right = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">TREE* p;</span><br><span class="line">inittree(&amp;p);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我么能用整形数来计算和存储队列，我们每次输入树的根时都会进行判定，左右，如果左没有就填充左，然后判定右边，不同的时，每次录入都会判定左右的根是否为空，然后按层次录入。从而每次录入时进行队列的录入，于是完成了层次遍历的存储条件。</p><hr><h1 id="3-资料参考"><a href="#3-资料参考" class="headerlink" title="3. 资料参考"></a>3. 资料参考</h1><p>【UP从0到1带你手撕数据结构全集(C语言版)】<a href="https://www.bilibili.com/video/BV1W64y1z7jh?p=13&amp;vd_source=602097138258a0057a732e44579de1ed">https://www.bilibili.com/video/BV1W64y1z7jh?p=13&amp;vd_source=602097138258a0057a732e44579de1ed</a></p><p>【数据结构上机-通过层次遍历演示完全二叉树的建立与遍历-C语言上机代码完整实现】<a href="https://www.bilibili.com/video/BV1PF411E7ja?vd_source=602097138258a0057a732e44579de1ed">https://www.bilibili.com/video/BV1PF411E7ja?vd_source=602097138258a0057a732e44579de1ed</a></p><p>【层次遍历C语言实现】<a href="https://www.bilibili.com/video/BV1HM4y1u7fV?vd_source=602097138258a0057a732e44579de1ed">https://www.bilibili.com/video/BV1HM4y1u7fV?vd_source=602097138258a0057a732e44579de1ed</a></p>]]></content>
    
    
    <summary type="html">从c语言算法——树的结构</summary>
    
    
    
    <category term="c算法" scheme="https://www.lysnowq.cn/categories/c%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c算法" scheme="https://www.lysnowq.cn/tags/c%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="https://www.lysnowq.cn/posts/ef3a3fcc.html"/>
    <id>https://www.lysnowq.cn/posts/ef3a3fcc.html</id>
    <published>2023-11-19T10:45:30.322Z</published>
    <updated>2024-09-22T15:44:07.522Z</updated>
    
    <content type="html"><![CDATA[<hr><p>预览预定义的代码结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRING</span> &#123;</span></span><br><span class="line"><span class="type">char</span>* st;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">&#125;STR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化字符串</span></span><br><span class="line">STR* <span class="title function_">initstring</span><span class="params">()</span> &#123;</span><br><span class="line">STR* str = (STR*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STR));</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* st = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strAssign</span><span class="params">(STR* str, STR* st)</span> &#123;</span><br><span class="line"><span class="comment">//判断返回的data是否有值,防止野指针的出现</span></span><br><span class="line"><span class="keyword">if</span> (!str-&gt;st)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(str-&gt;st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;<span class="comment">//临时变量储存长度</span></span><br><span class="line"><span class="type">char</span>* temp = st;</span><br><span class="line"><span class="keyword">while</span> (*temp)<span class="comment">//记录长度</span></span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">str-&gt;st = <span class="literal">NULL</span>;</span><br><span class="line">str-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp = st;<span class="comment">//因为上面temp依次递增已经轮到了末尾，所以这里再次赋值使其回到原位</span></span><br><span class="line">str-&gt;len = len;<span class="comment">//将len写入</span></span><br><span class="line">str-&gt;st = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));<span class="comment">//因为在字符串中最后一位为\0，所以要多一位。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++, temp++)<span class="comment">//写入字符</span></span><br><span class="line">&#123;</span><br><span class="line">str-&gt;st[i] = *temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印字符串</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">printchar</span><span class="params">(STR*str)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(i == <span class="number">0</span> ? <span class="string">&quot;%c&quot;</span> : <span class="string">&quot;-&gt;%c&quot;</span>, str-&gt;st[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="1-暴力匹配（BF算法）"><a href="#1-暴力匹配（BF算法）" class="headerlink" title="1. 暴力匹配（BF算法）"></a>1. 暴力匹配（BF算法）</h1><p>首先，暴力匹配需要一个主串和一个字串，，由字串和主串一一对应匹配，当主串与子串不匹配时从这次匹配的下一个开始依次判定匹配，直到匹配到最后一个字符。</p><p>示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力匹配代码块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceMatch</span><span class="params">(STR*master,STR*sub)</span> &#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len) &#123;</span><br><span class="line"><span class="keyword">if</span> (master-&gt;st[i] == sub-&gt;st[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == sub-&gt;len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;success\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数的运行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">STR* string1 = initstring();</span><br><span class="line">STR* string2 = initstring();</span><br><span class="line">strAssign(string1,<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">strAssign(string2, <span class="string">&quot;ELL&quot;</span>);</span><br><span class="line">printchar(string1);</span><br><span class="line">printchar(string2);</span><br><span class="line">forceMatch(string1,string2);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们定义了两个字符串string1，string2.并将其传入到forceMatch中进行匹配。从我们自己的角度可以看出来HELLO中是包含ELL的。那么这里，i和j分别代表string1（主字符串）和string2（子字符串）的匹配时对应的字符位置。然后从住字符串的第一个开始和子字符串中的字符一个跟着一个对比。如果失败就将主字符串移向上一次对比的下一个字符开始重新对比，j继续依次增加，直到j连续到所有字符串都符合或者对比到结尾还未对应时就结束（即不匹配），这里我们匹配就输出success，不匹配就输出fail</p><p>此处例子的运行结果如下：（这里用-“&gt;”隔开了）</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231119184417467.png" alt="image-20231119184417467"></p><hr><h1 id="2-kmp匹配"><a href="#2-kmp匹配" class="headerlink" title="2. kmp匹配"></a>2. kmp匹配</h1><ul><li>kmp算法相比于暴力算法，没有暴力匹配算法的回溯，可以快速定位匹配。避开了暴力算法的冗杂的回溯寻找过程。</li><li>kmp算法是一种高效算法，牺牲了一定的空间去保存next数组，提高了匹配效率。相当于保存了索引，引导程序快速找到切入点。</li><li>kmp算法时间复杂度为（n+m）(n为主串长度，m为副串长度)</li></ul><p>next数组：当该字符与主串不匹配后，值对应索引的字符要移动到跟主串不匹配的字符对齐。==next数组存储的为最大公共前后缀+1。==</p><p>在代码实现中我们用这种方式获取next数组，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取next数组</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">NEXT</span><span class="params">(STR* str)</span> &#123;</span><br><span class="line"><span class="type">int</span>* next1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * str-&gt;len);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next1[i] = j;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str-&gt;len - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || str-&gt;st[i] == str-&gt;st[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next1[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next1[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么在匹配时，我们应该是这样操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmpMatch</span><span class="params">(STR* master, STR* sub,<span class="type">int</span>*next)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp;j&lt;sub-&gt;len) &#123;</span><br><span class="line"><span class="keyword">if</span> (master-&gt;st[i] == sub-&gt;st[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == sub-&gt;len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fail!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码我呢可以注意到，与暴力破解最大的不同是，==我们只对j进行操作，并不对i进行操作，也就是不对主串操作。这是kmp匹配和暴力匹配最大的区别==</p><hr><h1 id="3-资料参考"><a href="#3-资料参考" class="headerlink" title="3.资料参考"></a>3.资料参考</h1><p>【KMP算法精讲（2）——什么是最长公共前后缀？】<a href="https://www.bilibili.com/video/BV1hX4y1C73S?vd_source=602097138258a0057a732e44579de1ed">https://www.bilibili.com/video/BV1hX4y1C73S?vd_source=602097138258a0057a732e44579de1ed</a></p><p>【UP从0到1带你手撕数据结构全集(C语言版)】<a href="https://www.bilibili.com/video/BV1W64y1z7jh?p=9&amp;vd_source=602097138258a0057a732e44579de1ed">https://www.bilibili.com/video/BV1W64y1z7jh?p=9&amp;vd_source=602097138258a0057a732e44579de1ed</a></p>]]></content>
    
    
    <summary type="html">c语言暴力匹配和kmp算法</summary>
    
    
    
    <category term="c算法" scheme="https://www.lysnowq.cn/categories/c%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c算法" scheme="https://www.lysnowq.cn/tags/c%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>内存</title>
    <link href="https://www.lysnowq.cn/posts/593ee330.html"/>
    <id>https://www.lysnowq.cn/posts/593ee330.html</id>
    <published>2023-11-17T02:09:44.638Z</published>
    <updated>2024-09-17T05:40:51.523Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-内存分区"><a href="#1-内存分区" class="headerlink" title="1. 内存分区"></a>1. 内存分区</h1><h3 id="1-1-代码区"><a href="#1-1-代码区" class="headerlink" title="1.1 代码区"></a>1.1 代码区</h3><blockquote><p>代码区时程序执行二进制指令的地方，代码区的空间储存的时自己已经写好运行的代码所在的内存空间。代码区，的权限只允许读取，代码区的数据是可以共享的。只读属性体现在程序在执行中无法修改（防止程序意外修改了它的指令）。并且也规划了局部变量的相关信息。</p></blockquote><h3 id="1-2-数据区"><a href="#1-2-数据区" class="headerlink" title="1.2 数据区"></a>1.2 数据区</h3><p>数据区又有： </p><ol><li>未初始化的数据区（bss）</li><li>初始化数据区（data）{包括静态局部变量和静态全局变量}</li><li>常量区</li></ol><h3 id="1-3-栈区（stack）"><a href="#1-3-栈区（stack）" class="headerlink" title="1.3 栈区（stack）"></a>1.3 栈区（stack）</h3><ul><li>栈区时系统为每一个程序分配的一个临时空间。储存的有局部变量，函数信息，函数参数和数组。</li><li><p>具有先进后出的特点，由系统分配和释放</p></li><li><p>栈区的大小为1m</p></li><li>在windows中栈区可以扩展为10m</li><li>在linux中可以扩展到16m</li></ul><h3 id="1-4-堆区（heap）（取决你的内存大小）"><a href="#1-4-堆区（heap）（取决你的内存大小）" class="headerlink" title="1.4 堆区（heap）（取决你的内存大小）"></a>1.4 堆区（heap）（取决你的内存大小）</h3><ul><li>用于存储大数据，图片，音乐，音频等文件</li><li>栈区需要手动开辟（malloc colloc realloc）</li><li>栈区的内存空间也需要手动释放（free）</li></ul><hr><p>在地址分配中，从低地址到高地址依次为：代码区&lt;数据区（常量区）&lt;数据区（data）&lt;数据区（bss）&lt;堆区  &lt; 栈区</p><hr><h1 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2. 执行过程"></a>2. 执行过程</h1><p>程序在加载到内存前，代码区和全局区（data和bss）的大小是固定的，程序运行期间不能改变。然后执行程序，系统将程序加载到内存。并且额外增加了栈区和堆区。</p><hr><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><ul><li><p><strong>定义变量时是从高地址往低地址存储，并且不连续（防止其他程序的篡改）。</strong></p></li><li><p><strong>在存储数组时是先开辟一块空间，再由低地址往高地址存储数据</strong></p></li><li><strong>栈区的空间是由高地址往低地址增长</strong></li><li><strong>遵循先进后出，后进先出的规则</strong></li></ul><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><ul><li>动态内存分配</li><li>需要手动开辟和释放</li><li>如果不释放，系统将在程序结束时释放</li></ul><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">程序在内存中的分布以及状态作用</summary>
    
    
    
    <category term="c基础" scheme="https://www.lysnowq.cn/categories/c%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c学习" scheme="https://www.lysnowq.cn/tags/c%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>全局、局部以及静态变量</title>
    <link href="https://www.lysnowq.cn/posts/58cc5c90.html"/>
    <id>https://www.lysnowq.cn/posts/58cc5c90.html</id>
    <published>2023-11-16T08:20:39.454Z</published>
    <updated>2024-09-17T05:40:16.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h1><blockquote><p>局部变量是指在代码块局部定义的变量，只能在对应的代码块中使用。离开了这个代码块范围就不允许再被使用。因为在数据存储时局部变量将会被储存在栈中，如同函数一样，使用完后会被销毁，而在声明变量时使用auto，但是一边由于程序默认为auto所以一般省略不写。</p><p>总的来说</p><p>局部变量：在函数内部定义的变量</p><p>作用域：函数内部。</p><p>生命周期：从变量创建到函数结束。</p></blockquote><p>示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中，我们定义了一个名字为a的整形变量（auto可以省略不写）,这里的变量a只能在main中使用，并且作用范围在定义了a直到main函数的结束。在第二个函数 text中，无法引用。如图：</p></blockquote><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231116160913307.png" alt="image-20231116160913307"></p><p>那么我们常用的for函数也是如此，如图：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231116160943406.png" alt="image-20231116160943406"></p><blockquote><p>显然我们看到，当i在for循环之外时已经无法使用，但是如果我们想让i也能使用时，那么我们可以如下方式写：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这样将i定义在main这个大范围的函数中就可以在for值直接调用i，并且对它做出了修改。</p><h1 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2. 全局变量"></a>2. 全局变量</h1><p>全局变量是指可以在同一个文件或项目文件夹中都可以调用的变量。它可以使得我们所有的文件或者函数可以通用一个变量。==但是当其他同项目文件的的文件需要使用时必须对它声明，用extern==,并且全局变量定义时可以不用赋值，系统会自动赋值为0。有此特性我们可以得出全局变量是储存在数据区没有栈区</p><p>总的来说</p><p>全局变量：在函数外部定义的变量</p><p>作用域：在整个项目文件夹</p><p>生命周期：从程序开始到结束</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">text</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">text();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">text</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看输出结果</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231116162228718.png" alt="image-20231116162228718"></p><p>上述就是一个很经典的全局变量。那么如果全局变量定义后又在局部定义一个同名变量该怎么办呢，看看如下示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231116164452444.png" alt="image-20231116164452444"></p><p>我们发现，这里不仅重复定义a没有报错，还将局部变量的a覆盖了全局变量的a，遵循着就近原则。我们再举一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231116165329383.png" alt="image-20231116165329383"></p><p>上述代码中，我们可以看到我们再函数体中又添加了一个大括号，里面写了些内容，这个叫做匿名内部函数，在执行完后内部数据也会被销毁。所以可知，内部函数不影响全局变量的值，全局函数也是如此，变化的值只适用于局部。</p><hr><h1 id="3-静态变量"><a href="#3-静态变量" class="headerlink" title="3. 静态变量"></a>3. 静态变量</h1><p>静态变量不同的是其数据储存方式和使用，局部静态变量和全局静态变量的生命周期都是由创建到程序结束为止，在局部静态变量中如果未赋值，则系统将会自动赋值为0，而全局静态变量的作用域也发生了改变。总的来说如下：</p><p>静态局部变量：在函数体中只会定义一次，可以对变量多次赋值。</p><p>作用域：函数体内</p><p>生命周期：从创建到程序结束。</p><p>静态全局变量：</p><p>作用域：只能在本文件中调用，不再支持对同项目文件调用。</p><p>生命周期：从创建到函数结束</p><p>静态变量定义方式：</p><p>静态局部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">text</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    text();</span><br><span class="line">    text();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><p><img src="https://lysnowq.oss-cn-shenzhen.aliyuncs.com/image-20231116170803564.png" alt="image-20231116170803564"></p><p>这里我们将text执行了两次发现a并没有被销毁，而是被保留，并且没有被重新赋值。</p><h1 id="4-全局函数和静态函数"><a href="#4-全局函数和静态函数" class="headerlink" title="4. 全局函数和静态函数"></a>4. 全局函数和静态函数</h1><p>所有的函数在默认情况下都是全局函数，可以供整个项目文件调用，而静态函数则是用static所定义的，与全局函数不同的是，静态函数的作用域变为仅供本体文件内部调用，无法由其他文件调用，而全局函数中整个项目文件夹中不能出现同名的函数，而静态函数允许不同文件定义相同名字的函数，静态函数也遵循就近原则，有限调用本文件的函数。</p><hr><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>b站的黑马程序员</p>]]></content>
    
    
    <summary type="html">c语言的变量及作用域范围以及生命周期</summary>
    
    
    
    <category term="c基础" scheme="https://www.lysnowq.cn/categories/c%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c学习" scheme="https://www.lysnowq.cn/tags/c%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
